<!DOCTYPE html>
<html lang="en">

  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{{ page.title | default: "Sprae" }} – reactive sprinkles</title>
    <meta name="description" content="{{ page.description | default: 'Sprae is a tiny (~5KB) reactive library for progressive enhancement using signal-powered attributes in HTML/JSX.' }}">
    <link rel="stylesheet" href="{{ '/assets/style.css' | relative_url }}" />
    <script type="module">
      import sprae, { use } from 'https://cdn.jsdelivr.net/npm/sprae/+esm'
      use({ prefix: 'data-' })
      sprae(document.body)
    </script>
  </head>

  <body>
    <!-- Spray effect - cursor cloud with inertia -->
    <div id="spray" data-scope="{
      clouds: [],
      mx: 0, my: 0,
      cx: 0, cy: 0,
      vx: 0, vy: 0,
      speed: 0,
      pressed: false,
      mouseEntered: false,
      MAX: 30,
      cursorSize: 54,
      cursorIntensity: 0.35,
      cursorOpacity: 1,

      init() {
        this.cx = innerWidth / 2
        this.cy = innerHeight / 2
        const loop = () => {
          this.update()
          requestAnimationFrame(loop)
        }
        loop()
      },

      press(e) {
        this.mx = e.pageX
        this.my = e.pageY
        this.pressed = true
      },

      release(e) {
        this.pressed = false
        // Add current cursor state as released cloud
        const clouds = [...this.clouds]
        if (clouds.length >= this.MAX) {
          clouds.shift()
        }
        // Capture speed fade so released cloud doesn't jump opacity
        const speedFade = Math.max(0, 1 - this.speed * 0.1)
        clouds.push({
          id: Date.now(),
          x: this.cx, y: this.cy,
          vx: this.vx, vy: this.vy,
          size: this.cursorSize,
          intensity: this.cursorIntensity,
          fade: speedFade,
          age: 0
        })
        this.clouds = clouds
        // Reset cursor
        this.cx = e.pageX
        this.cy = e.pageY
        this.vx = 0
        this.vy = 0
        this.cursorSize = 54
        this.cursorIntensity = 0
        this.cursorOpacity = 0
      },

      move(e) {
        if (!this.mouseEntered) {
          this.mouseEntered = true
          this.cx = e.pageX
          this.cy = e.pageY
        }
        this.mx = e.pageX
        this.my = e.pageY
      },

      update() {
        const pageH = Math.max(document.body.scrollHeight, document.documentElement.scrollHeight)

        // Cursor follows mouse - moves fraction of distance each frame (natural ease-out)
        this.vx = (this.mx - this.cx) * 0.03
        this.vy = (this.my - this.cy) * 0.03
        this.cx += this.vx
        this.cy += this.vy

        // Track speed for transparency effect
        this.speed = Math.sqrt(this.vx * this.vx + this.vy * this.vy)

        // While pressed, grow cursor cloud
        if (this.pressed) {
          this.cursorSize += 1
          this.cursorIntensity = Math.min(1, this.cursorIntensity + 0.06)
        } else {
          // Fade in cursor after release
          this.cursorOpacity = Math.min(1, this.cursorOpacity + 0.01)
          this.cursorIntensity = Math.min(0.35, this.cursorIntensity + 0.005)
        }

        // Update released clouds
        for (const c of this.clouds) {
          c.age++
          c.vy += 0.015
          c.vx *= 0.99
          c.vy *= 0.995
          c.vx += (Math.random() - 0.5) * 0.02
          c.x += c.vx
          c.y += c.vy

          // Gradually start growing (smooth transition from cursor)
          const growRate = Math.min(1, c.age / 30) * 0.4 / (1 + c.age * 0.008)
          c.size += growRate

          // Gradually restore fade from speed
          c.fade = Math.min(1, c.fade + 0.01)

          // Very slow intensity fade
          c.intensity = Math.max(0.05, c.intensity * 0.9995)

          // Settle at bottom
          if (c.y > pageH - c.size * 0.3) {
            c.y = pageH - c.size * 0.3
            c.vy = 0
            c.vx *= 0.95
          }

          // Bounce sides
          if (c.x < c.size * 0.3) { c.x = c.size * 0.3; c.vx *= -0.3 }
          if (c.x > innerWidth - c.size * 0.3) { c.x = innerWidth - c.size * 0.3; c.vx *= -0.3 }
        }

        this.clouds = [...this.clouds]
      },

      vars(x, y, size, intensity, speedFade = 0) {
        const i = intensity
        const fade = Math.max(0, 1 - speedFade * 0.1)  // fade based on speed
        return {
          '--x': x + 'px',
          '--y': y + 'px',
          '--size': size + 'px',
          '--margin': -size * 0.5 + 'px',
          '--blur': size * 0.3 + 'px',
          '--center-s': (60 + i * 35) + '%',
          '--center-l': (50 - i * 35) + '%',
          '--alpha': (0.15 + i * 0.7) * fade,
          '--opacity': 1
        }
      },

      cursorVars() {
        const v = this.vars(this.cx, this.cy, this.cursorSize, this.cursorIntensity, this.speed)
        v['--opacity'] = this.mouseEntered ? this.cursorOpacity : 0
        return v
      },

      cloudVars(c) {
        const v = this.vars(c.x, c.y, c.size, c.intensity)
        v['--alpha'] = (0.15 + c.intensity * 0.7) * c.fade
        return v
      }
    }"
    data-onmousemove.document="move"
    data-onmousedown.document="press"
    data-onmouseup.document="release"
    data-fx.once="init()">
      <div class="cloud" data-style="cursorVars()"></div>
      <div class="cloud" data-each="c in clouds" data-style="cloudVars(c)"></div>
    </div>

    <div class="top-line"></div>
    <a href="https://github.com/dy/sprae" class="github-corner" aria-label="View on GitHub">
      <svg viewBox="0 0 250 250">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path class="octo-arm" d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor"
          style="transform-origin:130px 106px"></path>
        <path class="octo-body"
          d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
          fill="currentColor"></path>
      </svg>
    </a>

    <main>
      <nav>
        {% unless page.url == "/" or page.url == "/index.html" %}
        <a href="{{ '/' | relative_url }}" class="logo" aria-label="Home">∴</a>
        {% endunless %}
        <a href="docs">docs</a>
      </nav>

      <!-- Table of contents - auto-generated from headings -->
      <aside id="toc" data-scope="{
        items: [],
        active: '',
        activeSection: '',

        init() {
          // Collect all h2 and h4 headings from main content
          const headings = document.querySelectorAll('main h2, main h4')
          let currentSection = ''
          this.items = [...headings].map(h => {
            const item = {
              id: h.id || (h.id = h.textContent.trim().toLowerCase().replace(/[^a-z0-9]+/g, '-')),
              text: h.textContent.replace(/[#:]/g, '').trim().split('\n')[0].split('=')[0].trim(),
              level: h.tagName === 'H2' ? 2 : 4,
              section: ''
            }
            if (item.level === 2) currentSection = item.id
            item.section = currentSection
            return item
          })
          if (this.items.length) {
            this.active = this.items[0].id
            this.activeSection = this.items[0].section
          }
          this.onScroll()
        },

        onScroll() {
          const scrollY = window.scrollY + 100
          let newActive = this.items[0]?.id
          let newSection = this.items[0]?.section
          for (let i = this.items.length - 1; i >= 0; i--) {
            const el = document.getElementById(this.items[i].id)
            if (el && el.offsetTop <= scrollY) {
              newActive = this.items[i].id
              newSection = this.items[i].section
              break
            }
          }
          if (newActive !== this.active) {
            this.active = newActive
            this.activeSection = newSection
            setTimeout(() => {
              const activeEl = document.querySelector('#toc a.active')
              if (activeEl) activeEl.scrollIntoView({ block: 'nearest', behavior: 'smooth' })
            }, 50)
          }
        },

        isVisible(item) {
          return item.level === 2 || item.section === this.activeSection
        },

        goto(id) {
          const el = document.getElementById(id)
          if (el) el.scrollIntoView({ behavior: 'smooth' })
        }
      }"
      data-onscroll.window.throttle-50="onScroll"
      data-fx.once="init()">
        <nav data-if="items.length > 3">
          <a data-each="item in items"
             data-if="isVisible(item)"
             data-href="'#' + item.id"
             data-text="item.text"
             data-onclick.prevent="goto(item.id)"
             data-class="{active: active === item.id, indent: item.level === 4}"></a>
        </nav>
      </aside>

      {{ content }}
    </main>
  </body>

</html>
