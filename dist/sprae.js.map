{
  "version": 3,
  "sources": ["../core.js", "../store.js", "../signal.js", "../package.json", "../directive/if.js", "../directive/else.js", "../directive/text.js", "../directive/class.js", "../directive/style.js", "../directive/fx.js", "../directive/value.js", "../directive/ref.js", "../directive/scope.js", "../directive/each.js", "../directive/_.js", "../directive/spread.js", "../directive/event.js", "../directive/sequence.js", "../sprae.js"],
  "sourcesContent": ["import store, { _change, _signals } from \"./store.js\";\n\nexport const _dispose = (Symbol.dispose ||= Symbol(\"dispose\")),\n  _state = Symbol(\"state\"),\n  _on = Symbol('on'),\n  _off = Symbol('off'),\n  _add = Symbol('init');\n\nexport let prefix = ':', signal, effect, computed, batch = (fn) => fn(), untracked = batch;\n\nexport let directive = {}, modifier = {}\n\nlet currentDir = null;\n\n/**\n * Applies directives to an HTML element and manages its reactive state.\n *\n * @param {Element} [el=document.body] - The target HTML element to apply directives to.\n * @param {Object|store} [state] - Initial state values to populate the element's reactive state.\n * @returns {Object} The reactive state object associated with the element.\n */\nconst sprae = (el = document.body, state) => {\n  // repeated call can be caused by eg. :each with new objects with old keys\n  if (el[_state]) return Object.assign(el[_state], state)\n\n  // console.group('sprae', el)\n\n  // take over existing state instead of creating a clone\n  state = store(state || {})\n\n  let fx = [], offs = []\n\n  // on/off all effects\n  // we don't call prevOn as convention: everything defined before :else :if won't be disabled by :if\n  // imagine <x :onx=\"...\" :if=\"...\"/> - when :if is false, it disables directives after :if (calls _off) but ignores :onx\n  el[_on] = () => (!offs && (offs = fx.map(fn => fn())))\n  el[_off] = () => (offs?.map(off => off()), offs = null)\n\n  // destroy\n  el[_dispose] ||= () => (el[_off](), el[_off] = el[_on] = el[_dispose] = el[_add] = el[_state] = null)\n\n  const add = el[_add] = (el) => {\n    let _attrs = el.attributes, start;\n\n    // we iterate live collection (subsprae can init args)\n    if (_attrs) for (let i = 0; i < _attrs.length;) {\n      let { name, value } = _attrs[i]\n\n      if (name.startsWith(prefix)) {\n        el.removeAttribute(name)\n\n        currentDir = name;\n\n        // directive initializer can be redefined\n        fx.push(start = dir(el, name.slice(prefix.length), value, state)), offs.push(start())\n\n        // stop after subsprae like :each, :if, :scope etc.\n        if (_state in el) return\n      } else i++\n    }\n\n    // :if and :each replace element with text node, which tweaks .children length, but .childNodes length persists\n    // for (let i = 0, child; i < (el.childNodes.length); i++) child =  el.childNodes[i], child.nodeType == 1 && add(child)\n    for (let child of [...el.childNodes]) child.nodeType == 1 && add(child)\n  };\n\n  add(el);\n\n  // if element was spraed by inline :with/:if/:each/etc instruction (meaning it has state placeholder) - skip, otherwise save _state\n  if (el[_state] === undefined) el[_state] = state\n\n  // console.groupEnd()\n\n  return state;\n}\n\n// directive initializer\nexport let dir\n\n/**\n * Compiles an expression into an evaluator function.\n * @type {(dir:string, expr: string, clean?: string => string) => Function}\n */\nexport let compile\n\n/**\n * Parses an expression into an evaluator function, caching the result for reuse.\n *\n * @param {string} expr The expression to parse and compile into a function.\n * @returns {Function} The compiled evaluator function for the expression.\n */\nexport const parse = (expr) => {\n  let fn  = cache[expr=expr.trim()]\n  if (fn) return fn\n\n  let _expr = expr || 'undefined'\n\n  // if, const, let - no return\n  if (/^(if|let|const)\\b/.test(_expr) || /;(?![^{]*})/.test(_expr));\n  else _expr = `return ${_expr}`\n\n  // async expression\n  if (/\\bawait\\s/.test(_expr)) _expr = `return (async()=>{ ${_expr} })()`\n\n  // static time errors\n  try {\n    fn = compile(_expr)\n    // Object.defineProperty(fn, \"name\", { value: `\u2234 ${expr}` })\n  } catch (e) { console.error(`\u2234 ${e}\\n\\n${currentDir}=\"${expr}\"`) }\n\n  // run time errors\n  return cache[expr] = function (state, cb, _out) {\n    try {\n      let result = fn?.call(this, state)\n      // if cb is given (to handle async/await exprs, usually directive update) - call it with result and return a cleanup function\n      if (cb) return result?.then ? (result.then(v => _out = cb(v)), () => _out && call(_out)) : cb(result)\n      else return result\n    } catch (e) {\n      console.error(`\u2234 ${e}\\n\\n${currentDir}=\"${expr}\"`)\n    }\n  }\n}\nconst cache = {};\n\n\n\n/**\n * Configure sprae\n */\nexport const use = (s) => (\n  s.compile && (compile = s.compile),\n  s.prefix && (prefix = s.prefix),\n  s.signal && (signal = s.signal),\n  s.effect && (effect = s.effect),\n  s.computed && (computed = s.computed),\n  s.batch && (batch = s.batch),\n  s.untracked && (untracked = s.untracked),\n  s.dir && (dir = s.dir)\n)\n\n// modifier applier\nexport const decorate = (fn, mods) => {\n  while (mods.length) {\n    let [name, ...params] = mods.pop().split('-'), mod = modifier[name], wrapFn\n    if (mod) {\n      if ((wrapFn = mod(fn, ...params)) !== fn) {\n        for (let k in fn) wrapFn[k] ??= fn[k];\n        fn = wrapFn\n      }\n    }\n  }\n  return fn\n}\n\n// instantiated <template> fragment holder, like persisting fragment but with minimal API surface\nexport const frag = (tpl) => {\n  if (!tpl.nodeType) return tpl // existing tpl\n\n  let content = tpl.content.cloneNode(true), // document fragment holder of content\n    attributes = [...tpl.attributes],\n    ref = document.createTextNode(''),\n    // ensure at least one node\n    childNodes = (content.append(ref), [...content.childNodes])\n\n  return {\n    // get parentNode() { return childNodes[0].parentNode },\n    childNodes,\n    content,\n    remove: () => content.append(...childNodes),\n    replaceWith(el) {\n      if (el === ref) return\n      ref.before(el)\n      content.append(...childNodes)\n    },\n    attributes,\n    removeAttribute(name) { attributes.splice(attributes.findIndex(a => a.name === name), 1) },\n    // setAttributeNode() { }\n  }\n}\n\n// if value is function - return result of its call\nexport const call = (v, arg) => typeof v === 'function' ? v(arg) : v\n\n// camel to kebab\nexport const dashcase = (str) => str.replace(/[A-Z\\u00C0-\\u00D6\\u00D8-\\u00DE]/g, (match, i) => (i ? '-' : '') + match.toLowerCase());\n\n// set attr\nexport const attr = (el, name, v) => (v == null || v === false) ? el.removeAttribute(name) : el.setAttribute(name, v === true ? \"\" : v);\n\n// convert any-arg to className string\nexport const clsx = (c, _out = []) => !c ? '' : typeof c === 'string' ? c : (\n  Array.isArray(c) ? c.map(clsx) :\n    Object.entries(c).reduce((s, [k, v]) => !v ? s : [...s, k], [])\n).join(' ')\n\n// throttle function to (once per tick or other custom scheduler)\nexport const throttle = (fn, schedule = queueMicrotask) => {\n  let _planned = 0, arg;\n  const throttled = (e) => {\n    arg = e\n    if (!_planned++) fn(arg), schedule((_dirty = _planned > 1) => (\n      _planned = 0, _dirty && throttled(arg)\n    ));\n  }\n  return throttled;\n}\n\nexport const debounce = (fn, schedule = queueMicrotask, _count = 0) => (arg, _planned = ++_count) => schedule(() => (_planned == _count && fn(arg)))\n\nexport * from './store.js';\n\nexport default sprae\n", "// signals-based proxy\nimport { signal, computed, batch, untracked } from './core.js'\n\n\n// _signals allows both storing signals and checking instance, which would be difficult with WeakMap\nexport const _signals = Symbol('signals'),\n  // _change is a signal that tracks changes to the object keys or array length\n  _change = Symbol('change'),\n  // _set is stashed setter for computed values\n  _set = Symbol('set')\n\n// a hack to simulate sandbox for `with` in evaluator\nlet sandbox = true\n\n// object store is not lazy\n// parent defines parent scope or sandbox\nexport const store = (values, parent) => {\n  if (!values) return values\n\n  // ignore globals\n  // FIXME: handle via has trap\n  if (values[Symbol.toStringTag]) return values;\n\n  // bypass existing store\n  if (values[_signals]) return values\n\n  // non-objects: for array redirect to list\n  if (values.constructor !== Object) return Array.isArray(values) ? list(values) : values\n\n  // _change stores total number of keys to track new props\n  let keyCount = Object.keys(values).length,\n    signals = {}\n\n  // proxy conducts prop access to signals\n  let state = new Proxy(Object.assign(signals, {\n    [_change]: signal(keyCount),\n    [_signals]: signals\n  }), {\n    get: (_, k) => {\n      // console.log('GET', k, signals)\n      if (k in signals) return (signals[k] ? signals[k].valueOf() : signals[k])\n      return parent ? parent[k] : globalThis[k]\n    },\n\n    set: (_, k, v, _s) => {\n      // console.group('SET', k, v)\n      if (k in signals) return set(signals, k, v), 1\n\n      // turn off sandbox to check if parents have the prop - we don't want to create new prop in global scope\n      sandbox = false\n\n      // write transparency for parent scope, unlike prototype chain\n      // if prop is defined in parent scope (except global) - write there\n      if (parent && k in parent) {\n        parent[k] = v\n      }\n      // else create in current scope\n      else {\n        create(signals, k, v)\n        signals[_change].value = ++keyCount\n      }\n\n      sandbox = true\n\n      // console.groupEnd()\n      // bump length for new signal\n      return 1\n    },\n\n    // FIXME: try to avild calling Symbol.dispose here. Maybe _delete method?\n    deleteProperty: (_, k) => {\n      k in signals && (k[0] != '_' && signals[k]?.[Symbol.dispose]?.(), delete signals[k], signals[_change].value = --keyCount)\n      return 1\n    },\n\n    // subscribe to length when spreading\n    ownKeys: () => (signals[_change].value, Reflect.ownKeys(signals)),\n\n    // sandbox prevents writing to global\n    has: (_, k) => {\n      if (k in signals) return true\n      if (parent) return k in parent\n      return sandbox\n    }\n  })\n\n  // init signals for values\n  const descs = Object.getOwnPropertyDescriptors(values)\n\n  for (let k in values) {\n    // getter turns into computed\n    if (descs[k]?.get)\n      // stash setter\n      (signals[k] = computed(descs[k].get.bind(state)))[_set] = descs[k].set?.bind(state);\n\n    // init blank signal - make sure we don't take prototype one\n    else create(signals, k, values[k])\n  }\n\n  return state\n}\n\n// array store - signals are lazy since arrays can be very large & expensive\nconst list = (values, parent = globalThis) => {\n\n  // gotta fill with null since proto methods like .reduce may fail\n  let signals = Array(values.length).fill(null),\n\n    // if .length was accessed from mutator (.push/etc) method\n    isMut = false,\n\n    // since array mutator methods read .length internally only once, we disable it on the moment of call, allowing rest of operations to be reactive\n    mut = fn => function () { isMut = true; return fn.apply(this, arguments); },\n\n    length = signal(values.length),\n\n    // proxy passes prop access to signals\n    state = new Proxy(\n      Object.assign(signals, {\n        [_change]: length,\n        [_signals]: signals,\n        // patch mutators\n        push: mut(signals.push),\n        pop: mut(signals.pop),\n        shift: mut(signals.shift),\n        unshift: mut(signals.unshift),\n        splice: mut(signals.splice),\n      }),\n      {\n        get(_, k) {\n          // console.log('GET', k, isMut)\n\n          // if .length is read within mutators - peek signal to avoid recursive subscription\n          // we need to ignore it only once and keep for the rest of the mutator call\n          if (k === 'length') return isMut ? (isMut = false, signals.length) : length.value;\n\n          // non-numeric\n          if (typeof k === 'symbol' || isNaN(k)) return signals[k]?.valueOf() ?? parent[k];\n\n          // create signal (lazy)\n          // NOTE: if you decide to unlazy values, think about large arrays - init upfront can be costly\n          return (signals[k] ??= signal(store(values[k]))).valueOf()\n        },\n\n        set(_, k, v) {\n          // console.log('SET', k, v)\n\n          // .length\n          if (k === 'length') {\n            // force cleaning up tail\n            for (let i = v; i < signals.length; i++) delete state[i]\n            // .length = N directly\n            length.value = signals.length = v;\n          }\n\n          // force changing length, if eg. a=[]; a[1]=1 - need to come after setting the item\n          else if (k >= signals.length) create(signals, k, v), state.length = +k + 1\n\n          // existing signal\n          else signals[k] ? set(signals, k, v) : create(signals, k, v)\n\n          return 1\n        },\n\n        // dispose notifies any signal deps, like :each\n        deleteProperty: (_, k) => (signals[k]?.[Symbol.dispose]?.(), delete signals[k], 1),\n      })\n\n  return state\n}\n\n// create signal value, skip untracked\nconst create = (signals, k, v) => (signals[k] = (k[0] == '_' || v?.peek) ? v : signal(store(v)))\n\n// set/update signal value\nconst set = (signals, k, v, _s, _v) => {\n  // skip unchanged (although can be handled by last condition - we skip a few checks this way)\n  return k[0] === '_' ? (signals[k] = v) :\n    (v !== (_v = (_s = signals[k]).peek())) && (\n      // stashed _set for value with getter/setter\n      _s[_set] ? _s[_set](v) :\n        // patch array\n        Array.isArray(v) && Array.isArray(_v) ?\n          // if we update plain array (stored in signal) - take over value instead\n          // since input value can be store, we have to make sure we don't subscribe to its length or values\n          // FIXME: generalize to objects\n          _change in _v ?\n            untracked(() => batch(() => {\n              for (let i = 0; i < v.length; i++) _v[i] = v[i]\n              _v.length = v.length // forces deleting tail signals\n            })) :\n            (_s.value = v) :\n          // .x = y\n          (_s.value = store(v))\n    )\n}\n\n\n// make sure state contains first element of path, eg. `a` from `a.b[c]`\n// NOTE: we don't need since we force proxy sandbox\n// export const ensure = (state, expr, _name = expr.match(/^\\w+(?=\\s*(?:\\.|\\[|$))/)) => _name && (state[_signals][_name[0]] ??= null)\n\nexport default store\n", "// preact-signals minimal implementation\nlet current, depth = 0, batched;\n\n// default signals impl\n\nexport const signal = (v, _s, _obs = new Set, _v = () => _s.value) => (\n  _s = {\n    get value() {\n      current?.deps.add(_obs.add(current));\n      return v\n    },\n    set value(val) {\n      if (val === v) return\n      v = val;\n      for (let sub of _obs) batched ? batched.add(sub) : sub(); // notify effects\n    },\n    peek() { return v },\n    toJSON: _v, toString: _v, valueOf: _v\n  }\n)\n\nexport const effect = (fn, _teardown, _fx, _deps) => (\n  _fx = (prev) => {\n    let tmp = _teardown;\n    _teardown = null; // we null _teardown to avoid repeated call in case of recursive update\n    tmp?.call?.();\n    prev = current, current = _fx\n    if (depth++ > 10) throw 'Cycle detected';\n    try { _teardown = fn() } finally { current = prev; depth-- }\n  },\n  _fx.fn = fn,\n  _deps = _fx.deps = new Set(),\n\n  _fx(),\n  (dep) => { _teardown?.call?.(); for (dep of _deps) dep.delete(_fx); _deps.clear() }\n)\n\nexport const computed = (fn, _s = signal(), _c, _e, _v = () => _c.value) => (\n  _c = {\n    get value() {\n      _e ||= effect(() => _s.value = fn());\n      return _s.value\n    },\n    peek: _s.peek,\n    toJSON: _v, toString: _v, valueOf: _v\n  }\n)\n\nexport const batch = (fn, _first = !batched, _list) => {\n  batched ??= new Set;\n  try { fn(); }\n  finally { if (_first) { [batched, _list] = [null, batched]; for (const fx of _list) fx(); } }\n}\n\nexport const untracked = (fn, _prev, _v) => (_prev = current, current = null, _v = fn(), current = _prev, _v)\n", "{\n  \"name\": \"sprae\",\n  \"description\": \"DOM microhydration\",\n  \"version\": \"12.3.0\",\n  \"main\": \"./sprae.js\",\n  \"module\": \"./sprae.js\",\n  \"umd:main\": \"dist/sprae.umd.js\",\n  \"unpkg\": \"dist/sprae.umd.js\",\n  \"types\": \"dist/sprae.d.ts\",\n  \"type\": \"module\",\n  \"files\": [\n    \"core.js\",\n    \"sprae.js\",\n    \"store.js\",\n    \"signal.js\",\n    \"micro.js\",\n    \"directive\",\n    \"dist\"\n  ],\n  \"devDependencies\": {\n    \"@preact/signals\": \"^2.0.4\",\n    \"@preact/signals-core\": \"^1.8.0\",\n    \"@webreflection/signal\": \"^2.1.2\",\n    \"es-module-shims\": \"^1.10.0\",\n    \"esbuild\": \"^0.23.0\",\n    \"esbuild-plugin-umd-wrapper\": \"^2.0.3\",\n    \"esbuild-plugin-version-injector\": \"^1.2.1\",\n    \"hyperf\": \"^1.7.0\",\n    \"jsdom\": \"^27.0.0\",\n    \"requestidlecallback\": \"^0.3.0\",\n    \"signal-polyfill\": \"^0.1.1\",\n    \"subscript\": \"^9.1.0\",\n    \"tst\": \"^8.0.2\",\n    \"ulive\": \"^1.0.7\",\n    \"usignal\": \"^0.9.0\",\n    \"wait-please\": \"^3.1.0\"\n  },\n  \"scripts\": {\n    \"test\": \"node -r ./test/register.cjs test/test.js\",\n    \"build\": \"node .esbuild.js\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/dy/sprae.git\"\n  },\n  \"keywords\": [\n    \"hydration\",\n    \"progressive\",\n    \"progressive enhancement\",\n    \"signals\",\n    \"directives\",\n    \"preact-signals\",\n    \"reactive\",\n    \"template-parts\",\n    \"petit-vue\",\n    \"alpinejs\",\n    \"templating\"\n  ],\n  \"author\": \"Dmitry Iv <df.creative@gmail.com>\",\n  \"license\": \"MIT\",\n  \"bugs\": {\n    \"url\": \"https://github.com/dy/sprae/issues\"\n  },\n  \"homepage\": \"https://github.com/dy/sprae#readme\"\n}\n", "// \"centralized\" version of :if\nimport sprae, { throttle, _on, _off, _state, frag } from '../core.js';\n\n// :if=\"a\"\nexport default (el, state) => {\n  let _holder, _el, _match\n\n  // new element :if\n  if (!el._holder) {\n    // mark el as fake-spraed to delay init, since we sprae rest when branch matches, both :if and :else :if\n    el[_state] ??= null\n\n    _el = el.content ? frag(el) : el\n\n    el.replaceWith(_holder = document.createTextNode(''))\n    _el._holder = _holder._holder = _holder\n\n\n    _holder._clauses = [_el._clause = [_el, false]]\n\n    _holder.update = throttle(() => {\n      let match = _holder._clauses.find(([, s]) => s)\n\n      if (match != _match) {\n        _match?.[0].remove()\n        _match?.[0][_off]?.()\n        if (_match = match) {\n          _holder.before(_match[0].content || _match[0])\n          // there's no :else after :if, so lazy-sprae here doesn't risk adding own destructor to own list of destructors\n          !_match[0][_state] ? (delete _match[0][_state], sprae(_match[0], state)) : _match[0][_on]?.()\n        }\n      }\n    })\n  }\n  // :else :if needs to be spraed all over to have clean list of offable effects\n  else sprae(_el = el, state)\n\n  // :else may have children to init which is called after :if\n  // or preact can schedule :else after :if, so we ensure order of call by next tick\n  return value => {\n    _el._clause[1] = value\n    _el._holder.update()\n  }\n}\n", "import { _on, _off, _state, frag } from '../core.js';\n\n\n// NOTE: we can reach :else counterpart whereas prev :else :if is on hold\nexport default (el) => {\n  let _el, _prev = el\n\n  _el = el.content ? frag(el) : el\n\n  // find holder\n  while (_prev && !(_el._holder = _prev._holder)) _prev = _prev.previousSibling\n\n  el.remove()\n  el[_state] = null // mark as fake-spraed to stop further init, to lazy-sprae when branch matches\n\n  _el._holder._clauses.push(_el._clause = [_el, true])\n\n  return _el._holder.update\n}\n", "import { frag, call } from \"../core.js\"\n\nexport default el => (\n  // <template :text=\"a\"/> or previously initialized template\n  el.content && el.replaceWith(el = frag(el).childNodes[0]),\n  v => (v = v && call(v, el.textContent), el.textContent = v == null ? \"\" : v)\n)\n", "import { clsx, call, decorate } from \"../core.js\";\n\nexport default (el, st, ex, name) => {\n  let _cur = new Set, _new\n\n  // redefine target, if modifiers have one\n  name.includes('.') && (el = decorate({target:el}, name.split('.').slice(1)).target ?? el)\n\n  return (v) => {\n    _new = new Set\n    if (v) clsx(call(v, el.className)).split(' ').map(c => c && _new.add(c))\n    for (let c of _cur) if (_new.has(c)) _new.delete(c); else el.classList.remove(c);\n    for (let c of _cur = _new) el.classList.add(c)\n  }\n}\n", "import { call, attr, decorate } from \"../core.js\";\n\nexport default (el, st, ex, name) => {\n  let _static;\n\n  // redefine target, if modifiers have one\n  if (name.includes('.')) el = decorate({target:el}, name.split('.').slice(1)).target ?? el;\n\n  return v => {\n    if (!_static) { _static = el.getAttribute(\"style\") }\n    if (v) v = call(v, el.style)\n    if (typeof v === \"string\") attr(el, \"style\", _static + '; ' + v);\n    else {\n      if (_static) attr(el, \"style\", _static);\n      // NOTE: we skip names not starting with a letter - eg. el.style stores properties as { 0: --x } or JSDOM has _pfx\n      for (let k in v) k[0] == '-' ? el.style.setProperty(k, v[k]) : k[0] > 'A' && (el.style[k] = v[k])\n    }\n  }\n}\n", "import { call } from \"../core.js\"\n\nexport default () => call\n", "import sprae, { attr, parse, _state } from \"../core.js\";\n\n\n// create expression setter, reflecting value back to state\nexport const setter = (expr, _set = parse(`${expr}=__`)) => (target, value) => {\n  // save value to stash\n  target.__ = value; _set(target), delete target.__\n}\n\nexport default (el, state, expr) => {\n  // bind back to value, but some values can be not bindable, eg. `:value=\"7\"`\n  try {\n    const set = setter(expr)\n    const handleChange = el.type === 'checkbox' ? () => set(state, el.checked) :\n      el.type === 'select-multiple' ? () => set(state, [...el.selectedOptions].map(o => o.value)) :\n        () => set(state, el.selectedIndex < 0 ? null : isNaN(el.valueAsNumber) ? el.value : el.valueAsNumber);\n\n    el.oninput = el.onchange = handleChange; // hope user doesn't redefine these manually via `.oninput = somethingElse` - it saves 5 loc vs addEventListener\n\n    if (el.type?.startsWith('select')) {\n      // select element also must observe any added/removed options or changed values (outside of sprae)\n      new MutationObserver(handleChange).observe(el, { childList: true, subtree: true, attributes: true });\n\n      // select options must be initialized before calling an update\n      sprae(el, state)\n    }\n\n    // initial state value - setter has already cached it, so parse is fast\n    parse(expr)(state) ?? handleChange()\n  } catch { }\n\n  return (el.type === \"text\" || el.type === \"\" || el.tagName === \"TEXTAREA\") ?\n    (value, _from, _to) => (\n      // we retain selection in input\n      (_from = el.selectionStart),\n      (_to = el.selectionEnd),\n      el.setAttribute(\"value\", (el.value = value == null ? \"\" : value)),\n      _from && el.setSelectionRange(_from, _to)\n    ) :\n    (el.type === \"checkbox\") ?\n      (value) => (el.checked = value, attr(el, \"checked\", value)) :\n      (el.type === 'radio') ? (value) => (\n        el.value === value && ((el.checked = value), attr(el, 'checked', value))\n      ) :\n        (el.type === \"select-one\") ?\n          (value) => {\n            for (let o of el.options)\n              o.value == value ? o.setAttribute(\"selected\", '') : o.removeAttribute(\"selected\");\n            el.value = value;\n          } :\n          (el.type === 'select-multiple') ? (value) => {\n            for (let o of el.options) o.removeAttribute('selected')\n            for (let v of value) el.querySelector(`[value=\"${v}\"]`).setAttribute('selected', '')\n          } :\n            (value) => (el.value = value);\n}\n", "import { parse } from \"../core.js\"\n// import { setter } from \"./value.js\"\n\nexport default (el, state, expr) => {\n  let fn = parse(expr)(state)\n\n  if (typeof fn == 'function') return {[Symbol.dispose]:fn(el)}\n\n  // NOTE: we have to set element statically (outside of effect) to avoid parasitic sub - multiple els with same :ref can cause recursion (eg. :each :ref=\"x\")\n  // FIXME: do via (setter(expr)(state, el))\n  else Object.defineProperty(state, expr, { value: el, configurable: true })\n}\n", "import sprae, { store, call, untracked, _state, _signals, signal } from '../core.js'\n\nexport default (el, rootState) => {\n  // 0 run pre-creates state to provide scope for the first effect - it can write vars in it, so we should already have it\n  // el[_state] even replaces own :scope effect state\n  let state = el[_state] = store({}, rootState), init = false;\n\n  // 1st run spraes subtree with values from scope - it can be postponed by modifiers (we isolate reads from parent effect)\n  // 2nd+ runs update subscope\n  return values => {\n    values = call(values, state);\n\n    // we bind to subscope to alleviate friction using scope method directly\n    // also returned props should force-create signals in subscope, not overwriting parent\n    if (values !== state) {\n      for (let k in values) {\n        // _add forces new prop, instead of checking parent\n        let v = typeof values[k] === 'function' ? values[k].bind(state) : values[k]\n        // update\n        if (k in state[_signals]) state[k] = v\n        // create\n        else (state[_signals][k] = (k[0] == '_' || v?.peek) ? v : signal(store(v)))\n      }\n    }\n\n    // Object.assign(subscope, call(values, subscope))\n    return !init && (init = true, delete el[_state], untracked(() => sprae(el, state)))\n  }\n}\n", "import sprae, { store, parse, _state, effect, _change, _signals, frag, throttle, debounce } from \"../core.js\";\n\nexport default (tpl, state, expr) => {\n  const [lhs, rhs] = expr.split(/\\bin\\b/)\n\n  let [itemVar, idxVar = \"$\"] = lhs.trim().replace(/\\(|\\)/g, '').split(/\\s*,\\s*/);\n\n  // we need :if to be able to replace holder instead of tpl for :if :each case\n  let holder = document.createTextNode(\"\");\n\n  // we re-create items any time new items are produced\n  let cur, keys, items, prevl = 0\n\n  // FIXME: pass items to update instead of global\n  let update = throttle(() => {\n    let i = 0, newItems = items, newl = newItems.length\n\n    // plain array update, not store (signal with array) - updates full list\n    if (cur && !cur[_change]) {\n      for (let s of cur[_signals] || []) s[Symbol.dispose]()\n      cur = null, prevl = 0\n    }\n\n\n    // delete\n    if (newl < prevl) cur.length = newl\n\n    // update, append, init\n    else {\n      // init\n      if (!cur) cur = newItems\n      // update\n      else while (i < prevl) cur[i] = newItems[i++]\n\n      // append\n      for (; i < newl; i++) {\n        cur[i] = newItems[i]\n\n        let idx = i,\n          // inherited state must be cheaper in terms of memory and faster in terms of performance, compared to creating a proxy store\n          // subscope = store({\n          //   // NOTE: since we simulate signal, we have to make sure it's actual signal, not fake one\n          //   // FIXME: try to avoid this, we also have issue with wrongly calling dispose in store on delete\n          //   [itemVar]: cur[_signals]?.[idx]?.peek ? cur[_signals]?.[idx] : cur[idx],\n          //   [idxVar]: keys ? keys[idx] : idx\n          // }, state)\n        subscope = Object.create(state, {\n          [itemVar]: { get: () => cur[idx] },\n          [idxVar]: { value: keys ? keys[idx] : idx }\n        })\n\n        let el = tpl.content ? frag(tpl) : tpl.cloneNode(true);\n\n        holder.before(el.content || el);\n        sprae(el, subscope);\n\n        // signal/holder disposal removes element\n        let _prev = ((cur[_signals] ||= [])[i] ||= {})[Symbol.dispose]\n        cur[_signals][i][Symbol.dispose] = () => {\n          _prev?.(), el[Symbol.dispose]?.(), el.remove()\n        };\n      }\n    }\n\n    prevl = newl\n  })\n\n  tpl.replaceWith(holder);\n  tpl[_state] = null // mark as fake-spraed, to preserve :-attribs for template\n\n  return Object.assign(value => {\n    // resolve new items\n    keys = null\n    if (typeof value === \"number\") items = Array.from({ length: value }, (_, i) => i + 1)\n    else if (value?.constructor === Object) keys = Object.keys(value), items = Object.values(value)\n    else items = value || []\n\n    // whenever list changes, we rebind internal change effect\n    return effect(() => {\n      // subscribe to items change (.length) - we do it every time (not just in update) since preact signals unsubscribes unused signals\n      items[_change]?.value\n\n      // make first render immediately, debounce subsequent renders\n      update()\n    })\n  }, {eval:parse(rhs)})\n}\n", "import { attr, call } from \"../core.js\";\n\nexport default (el, st, ex, name) => v => attr(el, name, v && call(v, el.getAttribute(name)))\n", "import { attr, dashcase } from \"../core.js\";\n\nexport default (target) => value => { for (let key in value) attr(target, dashcase(key), value[key]) }\n", "import { call, parse, decorate } from \"../core.js\"\n\nexport default (el, state, expr, name) => {\n  // wrap inline cb into function\n  // if (!/^(?:[\\w$]+|\\([^()]*\\))\\s*=>/.test(expr) && !/^function\\b/.test(expr)) expr = `()=>{${expr}}`;\n\n  const [type, ...mods] = name.slice(2).split('.'),\n    evaluate = parse(expr).bind(el),\n    trigger = decorate(Object.assign(e => evaluate(state, (fn) => fn && call(fn, e)), { target: el }), mods);\n\n  trigger.target.addEventListener(type, trigger, trigger)\n  return {\n    [Symbol.dispose]() {\n      trigger.target.removeEventListener(type, trigger)\n    }\n  }\n}\n", "// events directive with enabled aliases and sequences like :onclick.ctrl.once..keyup.enter\nimport { _dispose, call, parse, decorate } from \"../core.js\"\n\nexport default (el, state, expr, names) => {\n  let cur, // current step callback\n    off // current step disposal\n\n  let steps = names.split('..').map((step, i, { length }) => step.split(':').reduce(\n    (prev, str) => {\n      const [name, ...mods] = str.slice(2).split('.')\n\n      const evaluate = parse(expr).bind(el)\n\n      const trigger = decorate(Object.assign(\n        e => (!i ? evaluate(state, (fn) => cur = fn && call(fn, e)) : (cur = cur(e)), off(), off = steps[(i + 1) % length]()),\n        { target: el }\n      ), mods)\n\n\n      return (_poff) => (\n        _poff = prev?.(),\n        trigger.target.addEventListener(name, trigger, trigger),\n        () => (_poff?.(), trigger.target.removeEventListener(name, trigger))\n      )\n    }, null)\n  )\n\n  off = steps[0]()\n\n  return {\n    [Symbol.dispose]() {\n      off?.()\n    }\n  }\n}\n", "import store from \"./store.js\";\nimport { batch, computed, effect, signal, untracked } from './core.js';\nimport * as signals from './signal.js';\nimport sprae, { use, decorate, directive, modifier, parse, throttle, debounce, _off, _state, _on, _dispose, _add, call } from './core.js';\nimport pkg from './package.json' with { type: 'json' };\n\nimport _if from \"./directive/if.js\";\nimport _else from \"./directive/else.js\";\nimport _text from \"./directive/text.js\";\nimport _class from \"./directive/class.js\";\nimport _style from \"./directive/style.js\";\nimport _fx from \"./directive/fx.js\";\nimport _value from \"./directive/value.js\";\nimport _ref from \"./directive/ref.js\";\nimport _scope from \"./directive/scope.js\";\nimport _each from \"./directive/each.js\";\nimport _default from \"./directive/_.js\";\nimport _spread from \"./directive/spread.js\";\nimport _event from \"./directive/event.js\";\nimport _seq from \"./directive/sequence.js\";\n\n\nObject.assign(directive, {\n  _: (el, state, expr, name) => (name.startsWith('on') ? _event : _default)(el, state, expr, name),\n  '': _spread,\n  class: _class,\n  text: _text,\n  style: _style,\n  fx: _fx,\n  value: _value,\n  ref: _ref,\n  scope: _scope,\n  if: _if,\n  else: _else,\n  each: _each\n})\n\n\n/**\n * Directive initializer (with modifiers support)\n * @type {(el: HTMLElement, name:string, value:string, state:Object) => Function}\n * */\nconst dir = (target, name, expr, state) => {\n  let [dirName, ...mods] = name.split('.'), create = directive[dirName] || directive._\n\n  return () => {\n    let update = create(target, state, expr, name)\n\n    if (!update?.call) return update?.[_dispose]\n\n    // throttle prevents multiple updates within one tick as well as isolates stack for each update\n    let trigger = decorate(Object.assign(throttle(() => change.value++), { target }), mods),\n      change = signal(0), // signal authorized to trigger effect: 0 = init; >0 = trigger\n      count = 0, // called effect count\n      evaluate = update.eval ?? parse(expr).bind(target),\n      _out, out = () => (_out && call(_out), _out=null) // effect trigger and invoke may happen in the same tick, so it will be effect-within-effect call - we need to store output of evaluate to return from trigger effect\n\n    state =  target[_state] ?? state\n\n    return effect(() => (\n      // if planned count is same as actual count - plan new update, else update right away\n      change.value == count ? (trigger()) : (count = change.value, _out = evaluate(state, update)),\n      out\n    ))\n  }\n}\n\nObject.assign(modifier, {\n  // timing\n  debounce: (fn, _how = 250) => debounce(fn, (_how ||= 0, (fn) => setTimeout(fn, _how))),\n  throttle: (fn, _how = 250) => throttle(fn, (_how ||= 0, (fn) => setTimeout(fn, _how))),\n  tick: (fn) => (e) => (queueMicrotask(() => fn(e))),\n  raf: (fn) => (e) => requestAnimationFrame(() => fn(e)),\n  once: (fn, _done, _fn) => (_fn = (e) => !_done && (_done = 1, fn(e)), _fn.once = true, _fn),\n\n  // target\n  window: fn => (fn.target = fn.target.ownerDocument.defaultView, fn),\n  document: fn => (fn.target = fn.target.ownerDocument, fn),\n  root: fn => (fn.target = fn.target.ownerDocument.documentElement, fn),\n  body: fn => (fn.target = fn.target.ownerDocument.body, fn),\n  parent: fn => (fn.target = fn.target.parentNode, fn),\n  self: (fn) => (e) => (e.target === fn.target && fn(e)),\n  outside: (fn) => (e, _target) => (\n    _target = fn.target,\n    !_target.contains(e.target) && e.target.isConnected && (_target.offsetWidth || _target.offsetHeight)\n  ),\n\n  // events\n  prevent: (fn) => (e) => (e?.preventDefault(), fn(e)),\n  stop: (fn) => (e) => (e?.stopPropagation(), fn(e)),\n  immediate: (fn) => (e) => (e?.stopImmediatePropagation(), fn(e)),\n  passive: fn => (fn.passive = true, fn),\n  capture: fn => (fn.capture = true, fn),\n})\n\n// key testers\nconst keys = {\n  ctrl: e => e.ctrlKey || e.key === \"Control\" || e.key === \"Ctrl\",\n  shift: e => e.shiftKey || e.key === \"Shift\",\n  alt: e => e.altKey || e.key === \"Alt\",\n  meta: e => e.metaKey || e.key === \"Meta\",\n  cmd: e => e.metaKey || e.key === \"Command\",\n  arrow: e => e.key.startsWith(\"Arrow\"),\n  enter: e => e.key === \"Enter\",\n  esc: e => e.key.startsWith(\"Esc\"),\n  tab: e => e.key === \"Tab\",\n  space: e => e.key === \"\u00A0\" || e.key === \"Space\" || e.key === \" \",\n  delete: e => e.key === \"Delete\" || e.key === \"Backspace\",\n  digit: e => /^\\d$/.test(e.key),\n  letter: e => /^\\p{L}$/gu.test(e.key),\n  char: e => /^\\S$/.test(e.key),\n};\n\n// augment modifiers with key testers\nfor (let k in keys) modifier[k] = (fn, a, b) => (e) => keys[k](e) && (!a || keys[a]?.(e)) && (!b || keys[b]?.(e)) && fn(e)\n\n\nuse({\n  compile: expr => sprae.constructor(`with (arguments[0]) { ${expr} }`),\n  dir: (el, name, expr, state) => {\n    // sequences shortcut\n    if (name.includes('..')) return () => _seq(el, state, expr, name)[_dispose]\n    return name.split(':').reduce((prev, str) => {\n      let start = dir(el, str, expr, state)\n      return !prev ? start : (p, s) => (p = prev(), s = start(), () => { p(); s() })\n    }, null)\n  },\n  ...signals\n})\n\n\n// expose for runtime config\nsprae.use = use\nsprae.store = store\nsprae.directive = directive\nsprae.modifier = modifier\nsprae.version = pkg.version;\n\n\n/**\n * Lifecycle hanger: spraes automatically any new nodes\n */\nconst start = sprae.start = (root = document.body, values) => {\n  const state = store(values)\n  sprae(root, state);\n  const mo = new MutationObserver(mutations => {\n    for (const m of mutations) {\n      for (const el of m.addedNodes) {\n        // el can be spraed or removed by subsprae (like within :each/:if)\n        if (el.nodeType === 1 && el[_state] === undefined && root.contains(el)) {\n          // even if element has no spraeable attrs, some of its children can have\n          root[_add](el)\n          // sprae(el, state, root);\n        }\n      }\n      // for (const el of m.removedNodes) el[Symbol.dispose]?.()\n    }\n  });\n  mo.observe(root, { childList: true, subtree: true });\n  return state\n}\n\n\n// version placeholder for bundler\nsprae.version = \"12.3.0\"\n\nexport default sprae\nexport { sprae, store, signal, effect, computed, batch, untracked, start, use }\n"],
  "mappings": "6FAEO,IAAMA,EAAY,OAAO,UAAP,OAAO,QAAY,OAAO,SAAS,GAC1DC,EAAS,OAAO,OAAO,EACvBC,EAAM,OAAO,IAAI,EACjBC,EAAO,OAAO,KAAK,EACnBC,EAAO,OAAO,MAAM,EAEXC,EAAS,IAAKC,EAAQC,EAAQC,EAAUC,EAASC,GAAOA,EAAG,EAAGC,EAAYF,EAE1EG,EAAY,CAAC,EAAGC,EAAW,CAAC,EAEnCC,EAAa,KASXC,GAAQ,CAACC,EAAK,SAAS,KAAMC,IAAU,CAE3C,GAAID,EAAGf,CAAM,EAAG,OAAO,OAAO,OAAOe,EAAGf,CAAM,EAAGgB,CAAK,EAKtDA,EAAQC,EAAMD,GAAS,CAAC,CAAC,EAEzB,IAAIE,EAAK,CAAC,EAAGC,EAAO,CAAC,EAKrBJ,EAAGd,CAAG,EAAI,IAAO,CAACkB,IAASA,EAAOD,EAAG,IAAIT,GAAMA,EAAG,CAAC,GACnDM,EAAGb,CAAI,EAAI,KAAOiB,GAAM,IAAIC,GAAOA,EAAI,CAAC,EAAGD,EAAO,MAGlDJ,EAAAhB,KAAAgB,EAAAhB,GAAiB,KAAOgB,EAAGb,CAAI,EAAE,EAAGa,EAAGb,CAAI,EAAIa,EAAGd,CAAG,EAAIc,EAAGhB,CAAQ,EAAIgB,EAAGZ,CAAI,EAAIY,EAAGf,CAAM,EAAI,OAEhG,IAAMqB,EAAMN,EAAGZ,CAAI,EAAKY,GAAO,CAC7B,IAAIO,EAASP,EAAG,WAAYQ,EAG5B,GAAID,EAAQ,QAASE,EAAI,EAAGA,EAAIF,EAAO,QAAS,CAC9C,GAAI,CAAE,KAAAG,EAAM,MAAAC,CAAM,EAAIJ,EAAOE,CAAC,EAE9B,GAAIC,EAAK,WAAWrB,CAAM,GASxB,GARAW,EAAG,gBAAgBU,CAAI,EAEvBZ,EAAaY,EAGbP,EAAG,KAAKK,EAAQI,GAAIZ,EAAIU,EAAK,MAAMrB,EAAO,MAAM,EAAGsB,EAAOV,CAAK,CAAC,EAAGG,EAAK,KAAKI,EAAM,CAAC,EAGhFvB,KAAUe,EAAI,YACbS,GACT,CAIA,QAASI,IAAS,CAAC,GAAGb,EAAG,UAAU,EAAGa,EAAM,UAAY,GAAKP,EAAIO,CAAK,CACxE,EAEA,OAAAP,EAAIN,CAAE,EAGFA,EAAGf,CAAM,IAAM,SAAWe,EAAGf,CAAM,EAAIgB,GAIpCA,CACT,EAGWW,GAMAE,GAQEC,EAASC,GAAS,CAC7B,IAAItB,EAAMuB,GAAMD,EAAKA,EAAK,KAAK,CAAC,EAChC,GAAItB,EAAI,OAAOA,EAEf,IAAIwB,EAAQF,GAAQ,YAGhB,oBAAoB,KAAKE,CAAK,GAAK,cAAc,KAAKA,CAAK,IAC1DA,EAAQ,UAAUA,CAAK,IAGxB,YAAY,KAAKA,CAAK,IAAGA,EAAQ,sBAAsBA,CAAK,SAGhE,GAAI,CACFxB,EAAKoB,GAAQI,CAAK,CAEpB,OAASC,EAAG,CAAE,QAAQ,MAAM,UAAKA,CAAC;AAAA;AAAA,EAAOrB,CAAU,KAAKkB,CAAI,GAAG,CAAE,CAGjE,OAAOC,GAAMD,CAAI,EAAI,SAAUf,EAAOmB,EAAIC,EAAM,CAC9C,GAAI,CACF,IAAIC,EAAS5B,GAAI,KAAK,KAAMO,CAAK,EAEjC,OAAImB,EAAWE,GAAQ,MAAQA,EAAO,KAAKC,GAAKF,EAAOD,EAAGG,CAAC,CAAC,EAAG,IAAMF,GAAQG,EAAKH,CAAI,GAAKD,EAAGE,CAAM,EACxFA,CACd,OAASH,EAAG,CACV,QAAQ,MAAM,UAAKA,CAAC;AAAA;AAAA,EAAOrB,CAAU,KAAKkB,CAAI,GAAG,CACnD,CACF,CACF,EACMC,GAAQ,CAAC,EAOFQ,EAAOC,IAClBA,EAAE,UAAYZ,GAAUY,EAAE,SAC1BA,EAAE,SAAWrC,EAASqC,EAAE,QACxBA,EAAE,SAAWpC,EAASoC,EAAE,QACxBA,EAAE,SAAWnC,EAASmC,EAAE,QACxBA,EAAE,WAAalC,EAAWkC,EAAE,UAC5BA,EAAE,QAAUjC,EAAQiC,EAAE,OACtBA,EAAE,YAAc/B,EAAY+B,EAAE,WAC9BA,EAAE,MAAQd,GAAMc,EAAE,MAIPC,EAAW,CAACjC,EAAIkC,IAAS,CACpC,KAAOA,EAAK,QAAQ,CAClB,GAAI,CAAClB,EAAM,GAAGmB,CAAM,EAAID,EAAK,IAAI,EAAE,MAAM,GAAG,EAAGE,EAAMjC,EAASa,CAAI,EAAGqB,EACrE,GAAID,IACGC,EAASD,EAAIpC,EAAI,GAAGmC,CAAM,KAAOnC,EAAI,CACxC,QAASsC,KAAKtC,EAAIqC,EAAAC,KAAAD,EAAAC,GAActC,EAAGsC,CAAC,GACpCtC,EAAKqC,CACP,CAEJ,CACA,OAAOrC,CACT,EAGauC,EAAQC,GAAQ,CAC3B,GAAI,CAACA,EAAI,SAAU,OAAOA,EAE1B,IAAIC,EAAUD,EAAI,QAAQ,UAAU,EAAI,EACtCE,EAAa,CAAC,GAAGF,EAAI,UAAU,EAC/BG,EAAM,SAAS,eAAe,EAAE,EAEhCC,GAAcH,EAAQ,OAAOE,CAAG,EAAG,CAAC,GAAGF,EAAQ,UAAU,GAE3D,MAAO,CAEL,WAAAG,EACA,QAAAH,EACA,OAAQ,IAAMA,EAAQ,OAAO,GAAGG,CAAU,EAC1C,YAAYtC,EAAI,CACVA,IAAOqC,IACXA,EAAI,OAAOrC,CAAE,EACbmC,EAAQ,OAAO,GAAGG,CAAU,EAC9B,EACA,WAAAF,EACA,gBAAgB1B,EAAM,CAAE0B,EAAW,OAAOA,EAAW,UAAUG,GAAKA,EAAE,OAAS7B,CAAI,EAAG,CAAC,CAAE,CAE3F,CACF,EAGac,EAAO,CAACD,EAAGiB,IAAQ,OAAOjB,GAAM,WAAaA,EAAEiB,CAAG,EAAIjB,EAGtDkB,GAAYC,GAAQA,EAAI,QAAQ,mCAAoC,CAACC,EAAOlC,KAAOA,EAAI,IAAM,IAAMkC,EAAM,YAAY,CAAC,EAGtHC,EAAO,CAAC5C,EAAIU,EAAMa,IAAOA,GAAK,MAAQA,IAAM,GAASvB,EAAG,gBAAgBU,CAAI,EAAIV,EAAG,aAAaU,EAAMa,IAAM,GAAO,GAAKA,CAAC,EAGzHsB,EAAO,CAACC,EAAGzB,EAAO,CAAC,IAAOyB,EAAS,OAAOA,GAAM,SAAWA,GACtE,MAAM,QAAQA,CAAC,EAAIA,EAAE,IAAID,CAAI,EAC3B,OAAO,QAAQC,CAAC,EAAE,OAAO,CAACpB,EAAG,CAACM,EAAGT,CAAC,IAAOA,EAAQ,CAAC,GAAGG,EAAGM,CAAC,EAAZN,EAAe,CAAC,CAAC,GAChE,KAAK,GAAG,EAHiC,GAM9BqB,EAAW,CAACrD,EAAIsD,EAAW,iBAAmB,CACzD,IAAIC,EAAW,EAAGT,EACZU,EAAa/B,GAAM,CACvBqB,EAAMrB,EACD8B,MAAYvD,EAAG8C,CAAG,EAAGQ,EAAS,CAACG,EAASF,EAAW,KACtDA,EAAW,EAAGE,GAAUD,EAAUV,CAAG,EACtC,EACH,EACA,OAAOU,CACT,EAEaE,GAAW,CAAC1D,EAAIsD,EAAW,eAAgBK,EAAS,IAAM,CAACb,EAAKS,EAAW,EAAEI,IAAWL,EAAS,IAAOC,GAAYI,GAAU3D,EAAG8C,CAAG,CAAE,EAI5Ic,EAAQvD,GC9MR,IAAMwD,EAAW,OAAO,SAAS,EAEtCC,EAAU,OAAO,QAAQ,EAEzBC,EAAO,OAAO,KAAK,EAGjBC,EAAU,GAIDC,EAAQ,CAACC,EAAQC,IAAW,CAQvC,GAPI,CAACD,GAIDA,EAAO,OAAO,WAAW,GAGzBA,EAAOL,CAAQ,EAAG,OAAOK,EAG7B,GAAIA,EAAO,cAAgB,OAAQ,OAAO,MAAM,QAAQA,CAAM,EAAIE,GAAKF,CAAM,EAAIA,EAGjF,IAAIG,EAAW,OAAO,KAAKH,CAAM,EAAE,OACjCI,EAAU,CAAC,EAGTC,EAAQ,IAAI,MAAM,OAAO,OAAOD,EAAS,CAC3C,CAACR,CAAO,EAAGU,EAAOH,CAAQ,EAC1B,CAACR,CAAQ,EAAGS,CACd,CAAC,EAAG,CACF,IAAK,CAACG,EAAGC,IAEHA,KAAKJ,EAAiBA,EAAQI,CAAC,EAAIJ,EAAQI,CAAC,EAAE,QAAQ,EAAIJ,EAAQI,CAAC,EAChEP,EAASA,EAAOO,CAAC,EAAI,WAAWA,CAAC,EAG1C,IAAK,CAACD,EAAGC,EAAGC,EAAGC,IAETF,KAAKJ,GAAgBO,GAAIP,EAASI,EAAGC,CAAC,EAAG,IAG7CX,EAAU,GAING,GAAUO,KAAKP,EACjBA,EAAOO,CAAC,EAAIC,GAIZG,EAAOR,EAASI,EAAGC,CAAC,EACpBL,EAAQR,CAAO,EAAE,MAAQ,EAAEO,GAG7BL,EAAU,GAIH,GAIT,eAAgB,CAACS,EAAGC,KAClBA,KAAKJ,IAAYI,EAAE,CAAC,GAAK,KAAOJ,EAAQI,CAAC,IAAI,OAAO,OAAO,IAAI,EAAG,OAAOJ,EAAQI,CAAC,EAAGJ,EAAQR,CAAO,EAAE,MAAQ,EAAEO,GACzG,GAIT,QAAS,KAAOC,EAAQR,CAAO,EAAE,MAAO,QAAQ,QAAQQ,CAAO,GAG/D,IAAK,CAACG,EAAGC,IACHA,KAAKJ,EAAgB,GACrBH,EAAeO,KAAKP,EACjBH,CAEX,CAAC,EAGKe,EAAQ,OAAO,0BAA0Bb,CAAM,EAErD,QAASQ,KAAKR,EAERa,EAAML,CAAC,GAAG,KAEXJ,EAAQI,CAAC,EAAIM,EAASD,EAAML,CAAC,EAAE,IAAI,KAAKH,CAAK,CAAC,GAAGR,CAAI,EAAIgB,EAAML,CAAC,EAAE,KAAK,KAAKH,CAAK,EAG/EO,EAAOR,EAASI,EAAGR,EAAOQ,CAAC,CAAC,EAGnC,OAAOH,CACT,EAGMH,GAAO,CAACF,EAAQC,EAAS,aAAe,CAG5C,IAAIG,EAAU,MAAMJ,EAAO,MAAM,EAAE,KAAK,IAAI,EAG1Ce,EAAQ,GAGRC,EAAMC,GAAM,UAAY,CAAE,OAAAF,EAAQ,GAAaE,EAAG,MAAM,KAAM,SAAS,CAAG,EAE1EC,EAASZ,EAAON,EAAO,MAAM,EAG7BK,EAAQ,IAAI,MACV,OAAO,OAAOD,EAAS,CACrB,CAACR,CAAO,EAAGsB,EACX,CAACvB,CAAQ,EAAGS,EAEZ,KAAMY,EAAIZ,EAAQ,IAAI,EACtB,IAAKY,EAAIZ,EAAQ,GAAG,EACpB,MAAOY,EAAIZ,EAAQ,KAAK,EACxB,QAASY,EAAIZ,EAAQ,OAAO,EAC5B,OAAQY,EAAIZ,EAAQ,MAAM,CAC5B,CAAC,EACD,CACE,IAAIG,EAAGC,EAAG,CAKR,OAAIA,IAAM,SAAiBO,GAASA,EAAQ,GAAOX,EAAQ,QAAUc,EAAO,MAGxE,OAAOV,GAAM,UAAY,MAAMA,CAAC,EAAUJ,EAAQI,CAAC,GAAG,QAAQ,GAAKP,EAAOO,CAAC,GAIvEJ,EAAAI,KAAAJ,EAAAI,GAAeF,EAAOP,EAAMC,EAAOQ,CAAC,CAAC,CAAC,IAAG,QAAQ,CAC3D,EAEA,IAAID,EAAGC,EAAGC,EAAG,CAIX,GAAID,IAAM,SAAU,CAElB,QAASW,EAAIV,EAAGU,EAAIf,EAAQ,OAAQe,IAAK,OAAOd,EAAMc,CAAC,EAEvDD,EAAO,MAAQd,EAAQ,OAASK,CAClC,MAGSD,GAAKJ,EAAQ,QAAQQ,EAAOR,EAASI,EAAGC,CAAC,EAAGJ,EAAM,OAAS,CAACG,EAAI,GAGpEJ,EAAQI,CAAC,EAAIG,GAAIP,EAASI,EAAGC,CAAC,EAAIG,EAAOR,EAASI,EAAGC,CAAC,EAE3D,MAAO,EACT,EAGA,eAAgB,CAACF,EAAGC,KAAOJ,EAAQI,CAAC,IAAI,OAAO,OAAO,IAAI,EAAG,OAAOJ,EAAQI,CAAC,EAAG,EAClF,CAAC,EAEL,OAAOH,CACT,EAGMO,EAAS,CAACR,EAASI,EAAGC,IAAOL,EAAQI,CAAC,EAAKA,EAAE,CAAC,GAAK,KAAOC,GAAG,KAAQA,EAAIH,EAAOP,EAAMU,CAAC,CAAC,EAGxFE,GAAM,CAACP,EAASI,EAAGC,EAAGC,EAAIU,IAEvBZ,EAAE,CAAC,IAAM,IAAOJ,EAAQI,CAAC,EAAIC,EACjCA,KAAOW,GAAMV,EAAKN,EAAQI,CAAC,GAAG,KAAK,KAElCE,EAAGb,CAAI,EAAIa,EAAGb,CAAI,EAAEY,CAAC,EAEnB,MAAM,QAAQA,CAAC,GAAK,MAAM,QAAQW,CAAE,EAIlCxB,KAAWwB,EACTC,EAAU,IAAMC,EAAM,IAAM,CAC1B,QAAS,EAAI,EAAG,EAAIb,EAAE,OAAQ,IAAKW,EAAG,CAAC,EAAIX,EAAE,CAAC,EAC9CW,EAAG,OAASX,EAAE,MAChB,CAAC,CAAC,EACDC,EAAG,MAAQD,EAEbC,EAAG,MAAQX,EAAMU,CAAC,GAStBc,EAAQxB,EC1Mf,IAAAyB,EAAA,GAAAC,GAAAD,EAAA,WAAAE,GAAA,aAAAC,GAAA,WAAAC,GAAA,WAAAC,GAAA,cAAAC,KACA,IAAIC,EAASC,GAAQ,EAAGC,EAIXJ,GAAS,CAACK,EAAGC,EAAIC,EAAO,IAAI,IAAKC,EAAK,IAAMF,EAAG,QAC1DA,EAAK,CACH,IAAI,OAAQ,CACV,OAAAJ,GAAS,KAAK,IAAIK,EAAK,IAAIL,CAAO,CAAC,EAC5BG,CACT,EACA,IAAI,MAAMI,EAAK,CACb,GAAIA,IAAQJ,EACZ,CAAAA,EAAII,EACJ,QAASC,KAAOH,EAAMH,EAAUA,EAAQ,IAAIM,CAAG,EAAIA,EAAI,EACzD,EACA,MAAO,CAAE,OAAOL,CAAE,EAClB,OAAQG,EAAI,SAAUA,EAAI,QAASA,CACrC,EAGWT,GAAS,CAACY,EAAIC,EAAWC,EAAKC,KACzCD,EAAOE,GAAS,CACd,IAAIC,EAAMJ,EAIV,GAHAA,EAAY,KACZI,GAAK,OAAO,EACZD,EAAOb,EAASA,EAAUW,EACtBV,KAAU,GAAI,KAAM,iBACxB,GAAI,CAAES,EAAYD,EAAG,CAAE,QAAE,CAAUT,EAAUa,EAAMZ,IAAQ,CAC7D,EACAU,EAAI,GAAKF,EACTG,EAAQD,EAAI,KAAO,IAAI,IAEvBA,EAAI,EACHI,GAAQ,CAAEL,GAAW,OAAO,EAAG,IAAKK,KAAOH,EAAOG,EAAI,OAAOJ,CAAG,EAAGC,EAAM,MAAM,CAAE,GAGvEhB,GAAW,CAACa,EAAIL,EAAKN,GAAO,EAAGkB,EAAIC,EAAIX,EAAK,IAAMU,EAAG,QAChEA,EAAK,CACH,IAAI,OAAQ,CACV,OAAAC,MAAOpB,GAAO,IAAMO,EAAG,MAAQK,EAAG,CAAC,GAC5BL,EAAG,KACZ,EACA,KAAMA,EAAG,KACT,OAAQE,EAAI,SAAUA,EAAI,QAASA,CACrC,EAGWX,GAAQ,CAACc,EAAIS,EAAS,CAAChB,EAASiB,IAAU,CACrDjB,MAAY,IAAI,KAChB,GAAI,CAAEO,EAAG,CAAG,QACZ,CAAU,GAAIS,EAAQ,CAAE,CAAChB,EAASiB,CAAK,EAAI,CAAC,KAAMjB,CAAO,EAAG,QAAWkB,KAAMD,EAAOC,EAAG,CAAG,CAAE,CAC9F,EAEarB,GAAY,CAACU,EAAIY,EAAOf,KAAQe,EAAQrB,EAASA,EAAU,KAAMM,EAAKG,EAAG,EAAGT,EAAUqB,EAAOf,GCtD1G,IAAAgB,GAAA,CACE,KAAQ,QACR,YAAe,qBACf,QAAW,SACX,KAAQ,aACR,OAAU,aACV,WAAY,oBACZ,MAAS,oBACT,MAAS,kBACT,KAAQ,SACR,MAAS,CACP,UACA,WACA,WACA,YACA,WACA,YACA,MACF,EACA,gBAAmB,CACjB,kBAAmB,SACnB,uBAAwB,SACxB,wBAAyB,SACzB,kBAAmB,UACnB,QAAW,UACX,6BAA8B,SAC9B,kCAAmC,SACnC,OAAU,SACV,MAAS,UACT,oBAAuB,SACvB,kBAAmB,SACnB,UAAa,SACb,IAAO,SACP,MAAS,SACT,QAAW,SACX,cAAe,QACjB,EACA,QAAW,CACT,KAAQ,2CACR,MAAS,kBACX,EACA,WAAc,CACZ,KAAQ,MACR,IAAO,qCACT,EACA,SAAY,CACV,YACA,cACA,0BACA,UACA,aACA,iBACA,WACA,iBACA,YACA,WACA,YACF,EACA,OAAU,oCACV,QAAW,MACX,KAAQ,CACN,IAAO,oCACT,EACA,SAAY,oCACd,EC5DA,IAAOC,GAAQ,CAACC,EAAIC,IAAU,CAJ9B,IAAAC,EAKE,IAAIC,EAASC,EAAKC,EAGlB,OAAKL,EAAG,QA2BHM,EAAMF,EAAMJ,EAAIC,CAAK,GAzBxBD,EAAAE,EAAGK,KAAHP,EAAAE,GAAe,MAEfE,EAAMJ,EAAG,QAAUQ,EAAKR,CAAE,EAAIA,EAE9BA,EAAG,YAAYG,EAAU,SAAS,eAAe,EAAE,CAAC,EACpDC,EAAI,QAAUD,EAAQ,QAAUA,EAGhCA,EAAQ,SAAW,CAACC,EAAI,QAAU,CAACA,EAAK,EAAK,CAAC,EAE9CD,EAAQ,OAASM,EAAS,IAAM,CAC9B,IAAIC,EAAQP,EAAQ,SAAS,KAAK,CAAC,CAAC,CAAEQ,CAAC,IAAMA,CAAC,EAE1CD,GAASL,IACXA,IAAS,CAAC,EAAE,OAAO,EACnBA,IAAS,CAAC,EAAEO,CAAI,IAAI,GAChBP,EAASK,KACXP,EAAQ,OAAOE,EAAO,CAAC,EAAE,SAAWA,EAAO,CAAC,CAAC,EAE5CA,EAAO,CAAC,EAAEE,CAAM,EAA0DF,EAAO,CAAC,EAAEQ,CAAG,IAAI,GAAtE,OAAOR,EAAO,CAAC,EAAEE,CAAM,EAAGD,EAAMD,EAAO,CAAC,EAAGJ,CAAK,IAG5E,CAAC,GAOIa,GAAS,CACdV,EAAI,QAAQ,CAAC,EAAIU,EACjBV,EAAI,QAAQ,OAAO,CACrB,CACF,ECvCA,IAAOW,GAASC,GAAO,CACrB,IAAIC,EAAKC,EAAQF,EAKjB,IAHAC,EAAMD,EAAG,QAAUG,EAAKH,CAAE,EAAIA,EAGvBE,GAAS,EAAED,EAAI,QAAUC,EAAM,UAAUA,EAAQA,EAAM,gBAE9D,OAAAF,EAAG,OAAO,EACVA,EAAGI,CAAM,EAAI,KAEbH,EAAI,QAAQ,SAAS,KAAKA,EAAI,QAAU,CAACA,EAAK,EAAI,CAAC,EAE5CA,EAAI,QAAQ,MACrB,EChBA,IAAOI,GAAQC,IAEbA,EAAG,SAAWA,EAAG,YAAYA,EAAKC,EAAKD,CAAE,EAAE,WAAW,CAAC,CAAC,EACxDE,IAAMA,EAAIA,GAAKC,EAAKD,EAAGF,EAAG,WAAW,EAAGA,EAAG,YAAcE,GAAY,KCHvE,IAAOE,GAAQ,CAACC,EAAIC,EAAIC,EAAIC,IAAS,CACnC,IAAIC,EAAO,IAAI,IAAKC,EAGpB,OAAAF,EAAK,SAAS,GAAG,IAAMH,EAAKM,EAAS,CAAC,OAAON,CAAE,EAAGG,EAAK,MAAM,GAAG,EAAE,MAAM,CAAC,CAAC,EAAE,QAAUH,GAE9EO,GAAM,CACZF,EAAO,IAAI,IACPE,GAAGC,EAAKC,EAAKF,EAAGP,EAAG,SAAS,CAAC,EAAE,MAAM,GAAG,EAAE,IAAIU,GAAKA,GAAKL,EAAK,IAAIK,CAAC,CAAC,EACvE,QAASA,KAAKN,EAAUC,EAAK,IAAIK,CAAC,EAAGL,EAAK,OAAOK,CAAC,EAAQV,EAAG,UAAU,OAAOU,CAAC,EAC/E,QAASA,KAAKN,EAAOC,EAAML,EAAG,UAAU,IAAIU,CAAC,CAC/C,CACF,ECZA,IAAOC,GAAQ,CAACC,EAAIC,EAAIC,EAAIC,IAAS,CACnC,IAAIC,EAGJ,OAAID,EAAK,SAAS,GAAG,IAAGH,EAAKK,EAAS,CAAC,OAAOL,CAAE,EAAGG,EAAK,MAAM,GAAG,EAAE,MAAM,CAAC,CAAC,EAAE,QAAUH,GAEhFM,GAAK,CAGV,GAFKF,IAAWA,EAAUJ,EAAG,aAAa,OAAO,GAC7CM,IAAGA,EAAIC,EAAKD,EAAGN,EAAG,KAAK,GACvB,OAAOM,GAAM,SAAUE,EAAKR,EAAI,QAASI,EAAU,KAAOE,CAAC,MAC1D,CACCF,GAASI,EAAKR,EAAI,QAASI,CAAO,EAEtC,QAASK,KAAKH,EAAGG,EAAE,CAAC,GAAK,IAAMT,EAAG,MAAM,YAAYS,EAAGH,EAAEG,CAAC,CAAC,EAAIA,EAAE,CAAC,EAAI,MAAQT,EAAG,MAAMS,CAAC,EAAIH,EAAEG,CAAC,EACjG,CACF,CACF,EChBA,IAAOC,GAAQ,IAAMC,ECEd,IAAMC,GAAS,CAACC,EAAMC,EAAOC,EAAM,GAAGF,CAAI,KAAK,IAAM,CAACG,EAAQC,IAAU,CAE7ED,EAAO,GAAKC,EAAOH,EAAKE,CAAM,EAAG,OAAOA,EAAO,EACjD,EAEOE,GAAQ,CAACC,EAAIC,EAAOP,IAAS,CAElC,GAAI,CACF,IAAMQ,EAAMT,GAAOC,CAAI,EACjBS,EAAeH,EAAG,OAAS,WAAa,IAAME,EAAID,EAAOD,EAAG,OAAO,EACvEA,EAAG,OAAS,kBAAoB,IAAME,EAAID,EAAO,CAAC,GAAGD,EAAG,eAAe,EAAE,IAAII,GAAKA,EAAE,KAAK,CAAC,EACxF,IAAMF,EAAID,EAAOD,EAAG,cAAgB,EAAI,KAAO,MAAMA,EAAG,aAAa,EAAIA,EAAG,MAAQA,EAAG,aAAa,EAExGA,EAAG,QAAUA,EAAG,SAAWG,EAEvBH,EAAG,MAAM,WAAW,QAAQ,IAE9B,IAAI,iBAAiBG,CAAY,EAAE,QAAQH,EAAI,CAAE,UAAW,GAAM,QAAS,GAAM,WAAY,EAAK,CAAC,EAGnGK,EAAML,EAAIC,CAAK,GAIjBL,EAAMF,CAAI,EAAEO,CAAK,GAAKE,EAAa,CACrC,MAAQ,CAAE,CAEV,OAAQH,EAAG,OAAS,QAAUA,EAAG,OAAS,IAAMA,EAAG,UAAY,WAC7D,CAACF,EAAOQ,EAAOC,KAEZD,EAAQN,EAAG,eACXO,EAAMP,EAAG,aACVA,EAAG,aAAa,QAAUA,EAAG,MAAQF,GAAgB,EAAW,EAChEQ,GAASN,EAAG,kBAAkBM,EAAOC,CAAG,GAEzCP,EAAG,OAAS,WACVF,IAAWE,EAAG,QAAUF,EAAOU,EAAKR,EAAI,UAAWF,CAAK,GACxDE,EAAG,OAAS,QAAYF,GACvBE,EAAG,QAAUF,IAAWE,EAAG,QAAUF,EAAQU,EAAKR,EAAI,UAAWF,CAAK,GAErEE,EAAG,OAAS,aACVF,GAAU,CACT,QAASM,KAAKJ,EAAG,QACfI,EAAE,OAASN,EAAQM,EAAE,aAAa,WAAY,EAAE,EAAIA,EAAE,gBAAgB,UAAU,EAClFJ,EAAG,MAAQF,CACb,EACCE,EAAG,OAAS,kBAAsBF,GAAU,CAC3C,QAASM,KAAKJ,EAAG,QAASI,EAAE,gBAAgB,UAAU,EACtD,QAASK,KAAKX,EAAOE,EAAG,cAAc,WAAWS,CAAC,IAAI,EAAE,aAAa,WAAY,EAAE,CACrF,EACGX,GAAWE,EAAG,MAAQF,CACnC,ECpDA,IAAOY,GAAQ,CAACC,EAAIC,EAAOC,IAAS,CAClC,IAAIC,EAAKC,EAAMF,CAAI,EAAED,CAAK,EAE1B,GAAI,OAAOE,GAAM,WAAY,MAAO,CAAC,CAAC,OAAO,OAAO,EAAEA,EAAGH,CAAE,CAAC,EAIvD,OAAO,eAAeC,EAAOC,EAAM,CAAE,MAAOF,EAAI,aAAc,EAAK,CAAC,CAC3E,ECTA,IAAOK,GAAQ,CAACC,EAAIC,IAAc,CAGhC,IAAIC,EAAQF,EAAGG,CAAM,EAAIC,EAAM,CAAC,EAAGH,CAAS,EAAGI,EAAO,GAItD,OAAOC,GAAU,CAKf,GAJAA,EAASC,EAAKD,EAAQJ,CAAK,EAIvBI,IAAWJ,EACb,QAASM,KAAKF,EAAQ,CAEpB,IAAIG,EAAI,OAAOH,EAAOE,CAAC,GAAM,WAAaF,EAAOE,CAAC,EAAE,KAAKN,CAAK,EAAII,EAAOE,CAAC,EAEtEA,KAAKN,EAAMQ,CAAQ,EAAGR,EAAMM,CAAC,EAAIC,EAE/BP,EAAMQ,CAAQ,EAAEF,CAAC,EAAKA,EAAE,CAAC,GAAK,KAAOC,GAAG,KAAQA,EAAIE,EAAOP,EAAMK,CAAC,CAAC,CAC3E,CAIF,MAAO,CAACJ,IAASA,EAAO,GAAM,OAAOL,EAAGG,CAAM,EAAGS,EAAU,IAAMC,EAAMb,EAAIE,CAAK,CAAC,EACnF,CACF,EC1BA,IAAOY,GAAQ,CAACC,EAAKC,EAAOC,IAAS,CACnC,GAAM,CAACC,EAAKC,CAAG,EAAIF,EAAK,MAAM,QAAQ,EAElC,CAACG,EAASC,EAAS,GAAG,EAAIH,EAAI,KAAK,EAAE,QAAQ,SAAU,EAAE,EAAE,MAAM,SAAS,EAG1EI,EAAS,SAAS,eAAe,EAAE,EAGnCC,EAAKC,EAAMC,EAAOC,EAAQ,EAG1BC,EAASC,EAAS,IAAM,CAd9B,IAAAC,EAAAC,EAeI,IAAIC,EAAI,EAAGC,EAAWP,EAAOQ,EAAOD,EAAS,OAG7C,GAAIT,GAAO,CAACA,EAAIW,CAAO,EAAG,CACxB,QAASC,KAAKZ,EAAIa,CAAQ,GAAK,CAAC,EAAGD,EAAE,OAAO,OAAO,EAAE,EACrDZ,EAAM,KAAMG,EAAQ,CACtB,CAIA,GAAIO,EAAOP,EAAOH,EAAI,OAASU,MAG1B,CAEH,GAAI,CAACV,EAAKA,EAAMS,MAEX,MAAOD,EAAIL,GAAOH,EAAIQ,CAAC,EAAIC,EAASD,GAAG,EAG5C,KAAOA,EAAIE,EAAMF,IAAK,CACpBR,EAAIQ,CAAC,EAAIC,EAASD,CAAC,EAEnB,IAAIM,EAAMN,EAQVO,GAAW,OAAO,OAAOtB,EAAO,CAC9B,CAACI,CAAO,EAAG,CAAE,IAAK,IAAMG,EAAIc,CAAG,CAAE,EACjC,CAAChB,CAAM,EAAG,CAAE,MAAOG,EAAOA,EAAKa,CAAG,EAAIA,CAAI,CAC5C,CAAC,EAEGE,EAAKxB,EAAI,QAAUyB,EAAKzB,CAAG,EAAIA,EAAI,UAAU,EAAI,EAErDO,EAAO,OAAOiB,EAAG,SAAWA,CAAE,EAC9BE,EAAMF,EAAID,EAAQ,EAGlB,IAAII,KAAUZ,EAAAP,EAAAM,EAAIO,KAAJb,EAAAM,GAAkB,CAAC,IAAnBE,KAAAD,EAAAC,GAA6B,CAAC,IAAG,OAAO,OAAO,EAC7DR,EAAIa,CAAQ,EAAEL,CAAC,EAAE,OAAO,OAAO,EAAI,IAAM,CACvCW,KAAQ,EAAGH,EAAG,OAAO,OAAO,IAAI,EAAGA,EAAG,OAAO,CAC/C,CACF,CACF,CAEAb,EAAQO,CACV,CAAC,EAED,OAAAlB,EAAI,YAAYO,CAAM,EACtBP,EAAI4B,CAAM,EAAI,KAEP,OAAO,OAAOC,IAEnBpB,EAAO,KACH,OAAOoB,GAAU,SAAUnB,EAAQ,MAAM,KAAK,CAAE,OAAQmB,CAAM,EAAG,CAACC,EAAGd,IAAMA,EAAI,CAAC,EAC3Ea,GAAO,cAAgB,QAAQpB,EAAO,OAAO,KAAKoB,CAAK,EAAGnB,EAAQ,OAAO,OAAOmB,CAAK,GACzFnB,EAAQmB,GAAS,CAAC,EAGhBE,EAAO,IAAM,CAElBrB,EAAMS,CAAO,GAAG,MAGhBP,EAAO,CACT,CAAC,GACA,CAAC,KAAKoB,EAAM5B,CAAG,CAAC,CAAC,CACtB,ECpFA,IAAO6B,GAAQ,CAACC,EAAIC,EAAIC,EAAIC,IAASC,GAAKC,EAAKL,EAAIG,EAAMC,GAAKE,EAAKF,EAAGJ,EAAG,aAAaG,CAAI,CAAC,CAAC,ECA5F,IAAOI,GAASC,GAAWC,GAAS,CAAE,QAASC,KAAOD,EAAOE,EAAKH,EAAQI,GAASF,CAAG,EAAGD,EAAMC,CAAG,CAAC,CAAE,ECArG,IAAOG,GAAQ,CAACC,EAAIC,EAAOC,EAAMC,IAAS,CAIxC,GAAM,CAACC,EAAM,GAAGC,CAAI,EAAIF,EAAK,MAAM,CAAC,EAAE,MAAM,GAAG,EAC7CG,EAAWC,EAAML,CAAI,EAAE,KAAKF,CAAE,EAC9BQ,EAAUC,EAAS,OAAO,OAAOC,GAAKJ,EAASL,EAAQU,GAAOA,GAAMC,EAAKD,EAAID,CAAC,CAAC,EAAG,CAAE,OAAQV,CAAG,CAAC,EAAGK,CAAI,EAEzG,OAAAG,EAAQ,OAAO,iBAAiBJ,EAAMI,EAASA,CAAO,EAC/C,CACL,CAAC,OAAO,OAAO,GAAI,CACjBA,EAAQ,OAAO,oBAAoBJ,EAAMI,CAAO,CAClD,CACF,CACF,ECbA,IAAOK,GAAQ,CAACC,EAAIC,EAAOC,EAAMC,IAAU,CACzC,IAAIC,EACFC,EAEEC,EAAQH,EAAM,MAAM,IAAI,EAAE,IAAI,CAACI,EAAMC,EAAG,CAAE,OAAAC,CAAO,IAAMF,EAAK,MAAM,GAAG,EAAE,OACzE,CAACG,EAAMC,IAAQ,CACb,GAAM,CAACC,EAAM,GAAGC,CAAI,EAAIF,EAAI,MAAM,CAAC,EAAE,MAAM,GAAG,EAExCG,EAAWC,EAAMb,CAAI,EAAE,KAAKF,CAAE,EAE9BgB,EAAUC,EAAS,OAAO,OAC9BC,IAAOV,EAAwDJ,EAAMA,EAAIc,CAAC,EAA/DJ,EAASb,EAAQkB,GAAOf,EAAMe,GAAMC,EAAKD,EAAID,CAAC,CAAC,EAAoBb,EAAI,EAAGA,EAAMC,GAAOE,EAAI,GAAKC,CAAM,EAAE,GACnH,CAAE,OAAQT,CAAG,CACf,EAAGa,CAAI,EAGP,OAAQQ,IACNA,EAAQX,IAAO,EACfM,EAAQ,OAAO,iBAAiBJ,EAAMI,EAASA,CAAO,EACtD,KAAOK,IAAQ,EAAGL,EAAQ,OAAO,oBAAoBJ,EAAMI,CAAO,GAEtE,EAAG,IAAI,CACT,EAEA,OAAAX,EAAMC,EAAM,CAAC,EAAE,EAER,CACL,CAAC,OAAO,OAAO,GAAI,CACjBD,IAAM,CACR,CACF,CACF,ECZA,OAAO,OAAOiB,EAAW,CACvB,EAAG,CAACC,EAAIC,EAAOC,EAAMC,KAAUA,EAAK,WAAW,IAAI,EAAIC,GAASC,IAAUL,EAAIC,EAAOC,EAAMC,CAAI,EAC/F,GAAIG,GACJ,MAAOC,GACP,KAAMC,GACN,MAAOC,GACP,GAAIC,GACJ,MAAOC,GACP,IAAKC,GACL,MAAOC,GACP,GAAIC,GACJ,KAAMC,GACN,KAAMC,EACR,CAAC,EAOD,IAAMC,GAAM,CAACC,EAAQf,EAAMD,EAAMD,IAAU,CACzC,GAAI,CAACkB,EAAS,GAAGC,CAAI,EAAIjB,EAAK,MAAM,GAAG,EAAGkB,EAAStB,EAAUoB,CAAO,GAAKpB,EAAU,EAEnF,MAAO,IAAM,CACX,IAAIuB,EAASD,EAAOH,EAAQjB,EAAOC,EAAMC,CAAI,EAE7C,GAAI,CAACmB,GAAQ,KAAM,OAAOA,IAASC,CAAQ,EAG3C,IAAIC,EAAUC,EAAS,OAAO,OAAOC,EAAS,IAAMC,EAAO,OAAO,EAAG,CAAE,OAAAT,CAAO,CAAC,EAAGE,CAAI,EACpFO,EAASC,EAAO,CAAC,EACjBC,EAAQ,EACRC,EAAWR,EAAO,MAAQS,EAAM7B,CAAI,EAAE,KAAKgB,CAAM,EACjDc,EAAMC,EAAM,KAAOD,GAAQE,EAAKF,CAAI,EAAGA,EAAK,MAE9C,OAAA/B,EAASiB,EAAOiB,CAAM,GAAKlC,EAEpBmC,EAAO,KAEZT,EAAO,OAASE,EAASL,EAAQ,GAAMK,EAAQF,EAAO,MAAOK,EAAOF,EAAS7B,EAAOqB,CAAM,GAC1FW,EACD,CACH,CACF,EAEA,OAAO,OAAOI,EAAU,CAEtB,SAAU,CAACC,EAAIC,EAAO,MAAQC,GAASF,GAAKC,MAAS,GAAID,GAAO,WAAWA,EAAIC,CAAI,EAAE,EACrF,SAAU,CAACD,EAAIC,EAAO,MAAQb,EAASY,GAAKC,MAAS,GAAID,GAAO,WAAWA,EAAIC,CAAI,EAAE,EACrF,KAAOD,GAAQG,GAAO,eAAe,IAAMH,EAAGG,CAAC,CAAC,EAChD,IAAMH,GAAQG,GAAM,sBAAsB,IAAMH,EAAGG,CAAC,CAAC,EACrD,KAAM,CAACH,EAAII,EAAOC,KAASA,EAAOF,GAAM,CAACC,IAAUA,EAAQ,EAAGJ,EAAGG,CAAC,GAAIE,EAAI,KAAO,GAAMA,GAGvF,OAAQL,IAAOA,EAAG,OAASA,EAAG,OAAO,cAAc,YAAaA,GAChE,SAAUA,IAAOA,EAAG,OAASA,EAAG,OAAO,cAAeA,GACtD,KAAMA,IAAOA,EAAG,OAASA,EAAG,OAAO,cAAc,gBAAiBA,GAClE,KAAMA,IAAOA,EAAG,OAASA,EAAG,OAAO,cAAc,KAAMA,GACvD,OAAQA,IAAOA,EAAG,OAASA,EAAG,OAAO,WAAYA,GACjD,KAAOA,GAAQG,GAAOA,EAAE,SAAWH,EAAG,QAAUA,EAAGG,CAAC,EACpD,QAAUH,GAAO,CAACG,EAAGG,KACnBA,EAAUN,EAAG,OACb,CAACM,EAAQ,SAASH,EAAE,MAAM,GAAKA,EAAE,OAAO,cAAgBG,EAAQ,aAAeA,EAAQ,eAIzF,QAAUN,GAAQG,IAAOA,GAAG,eAAe,EAAGH,EAAGG,CAAC,GAClD,KAAOH,GAAQG,IAAOA,GAAG,gBAAgB,EAAGH,EAAGG,CAAC,GAChD,UAAYH,GAAQG,IAAOA,GAAG,yBAAyB,EAAGH,EAAGG,CAAC,GAC9D,QAASH,IAAOA,EAAG,QAAU,GAAMA,GACnC,QAASA,IAAOA,EAAG,QAAU,GAAMA,EACrC,CAAC,EAGD,IAAMO,EAAO,CACX,KAAM,GAAK,EAAE,SAAW,EAAE,MAAQ,WAAa,EAAE,MAAQ,OACzD,MAAO,GAAK,EAAE,UAAY,EAAE,MAAQ,QACpC,IAAK,GAAK,EAAE,QAAU,EAAE,MAAQ,MAChC,KAAM,GAAK,EAAE,SAAW,EAAE,MAAQ,OAClC,IAAK,GAAK,EAAE,SAAW,EAAE,MAAQ,UACjC,MAAO,GAAK,EAAE,IAAI,WAAW,OAAO,EACpC,MAAO,GAAK,EAAE,MAAQ,QACtB,IAAK,GAAK,EAAE,IAAI,WAAW,KAAK,EAChC,IAAK,GAAK,EAAE,MAAQ,MACpB,MAAO,GAAK,EAAE,MAAQ,QAAO,EAAE,MAAQ,SAAW,EAAE,MAAQ,IAC5D,OAAQ,GAAK,EAAE,MAAQ,UAAY,EAAE,MAAQ,YAC7C,MAAO,GAAK,OAAO,KAAK,EAAE,GAAG,EAC7B,OAAQ,GAAK,YAAY,KAAK,EAAE,GAAG,EACnC,KAAM,GAAK,OAAO,KAAK,EAAE,GAAG,CAC9B,EAGA,QAASC,KAAKD,EAAMR,EAASS,CAAC,EAAI,CAACR,EAAIS,EAAGC,IAAOP,GAAMI,EAAKC,CAAC,EAAEL,CAAC,IAAM,CAACM,GAAKF,EAAKE,CAAC,IAAIN,CAAC,KAAO,CAACO,GAAKH,EAAKG,CAAC,IAAIP,CAAC,IAAMH,EAAGG,CAAC,EAGzHQ,EAAI,CACF,QAAS/C,GAAQgD,EAAM,YAAY,yBAAyBhD,CAAI,IAAI,EACpE,IAAK,CAACF,EAAIG,EAAMD,EAAMD,IAEhBE,EAAK,SAAS,IAAI,EAAU,IAAMgD,GAAKnD,EAAIC,EAAOC,EAAMC,CAAI,EAAEoB,CAAQ,EACnEpB,EAAK,MAAM,GAAG,EAAE,OAAO,CAACiD,EAAMC,IAAQ,CAC3C,IAAIC,EAAQrC,GAAIjB,EAAIqD,EAAKnD,EAAMD,CAAK,EACpC,OAAQmD,EAAe,CAACG,EAAGC,KAAOD,EAAIH,EAAK,EAAGI,EAAIF,EAAM,EAAG,IAAM,CAAEC,EAAE,EAAGC,EAAE,CAAE,GAA7DF,CACjB,EAAG,IAAI,EAET,GAAGG,CACL,CAAC,EAIDP,EAAM,IAAMD,EACZC,EAAM,MAAQQ,EACdR,EAAM,UAAYnD,EAClBmD,EAAM,SAAWb,EACjBa,EAAM,QAAUS,GAAI,QAMpB,IAAML,GAAQJ,EAAM,MAAQ,CAACU,EAAO,SAAS,KAAMC,IAAW,CAC5D,IAAM5D,EAAQyD,EAAMG,CAAM,EAC1B,OAAAX,EAAMU,EAAM3D,CAAK,EACN,IAAI,iBAAiB6D,GAAa,CAC3C,QAAWC,KAAKD,EACd,QAAW9D,KAAM+D,EAAE,WAEb/D,EAAG,WAAa,GAAKA,EAAGmC,CAAM,IAAM,QAAayB,EAAK,SAAS5D,CAAE,GAEnE4D,EAAKI,CAAI,EAAEhE,CAAE,CAMrB,CAAC,EACE,QAAQ4D,EAAM,CAAE,UAAW,GAAM,QAAS,EAAK,CAAC,EAC5C3D,CACT,EAIAiD,EAAM,QAAU,SAEhB,IAAOe,GAAQf",
  "names": ["_dispose", "_state", "_on", "_off", "_add", "prefix", "signal", "effect", "computed", "batch", "fn", "untracked", "directive", "modifier", "currentDir", "sprae", "el", "state", "store_default", "fx", "offs", "off", "add", "_attrs", "start", "i", "name", "value", "dir", "child", "compile", "parse", "expr", "cache", "_expr", "e", "cb", "_out", "result", "v", "call", "use", "s", "decorate", "mods", "params", "mod", "wrapFn", "k", "frag", "tpl", "content", "attributes", "ref", "childNodes", "a", "arg", "dashcase", "str", "match", "attr", "clsx", "c", "throttle", "schedule", "_planned", "throttled", "_dirty", "debounce", "_count", "core_default", "_signals", "_change", "_set", "sandbox", "store", "values", "parent", "list", "keyCount", "signals", "state", "signal", "_", "k", "v", "_s", "set", "create", "descs", "computed", "isMut", "mut", "fn", "length", "i", "_v", "untracked", "batch", "store_default", "signal_exports", "__export", "batch", "computed", "effect", "signal", "untracked", "current", "depth", "batched", "v", "_s", "_obs", "_v", "val", "sub", "fn", "_teardown", "_fx", "_deps", "prev", "tmp", "dep", "_c", "_e", "_first", "_list", "fx", "_prev", "package_default", "if_default", "el", "state", "_a", "_holder", "_el", "_match", "core_default", "_state", "frag", "throttle", "match", "s", "_off", "_on", "value", "else_default", "el", "_el", "_prev", "frag", "_state", "text_default", "el", "frag", "v", "call", "class_default", "el", "st", "ex", "name", "_cur", "_new", "decorate", "v", "clsx", "call", "c", "style_default", "el", "st", "ex", "name", "_static", "decorate", "v", "call", "attr", "k", "fx_default", "call", "setter", "expr", "_set", "parse", "target", "value", "value_default", "el", "state", "set", "handleChange", "o", "core_default", "_from", "_to", "attr", "v", "ref_default", "el", "state", "expr", "fn", "parse", "scope_default", "el", "rootState", "state", "_state", "store", "init", "values", "call", "k", "v", "_signals", "signal", "untracked", "core_default", "each_default", "tpl", "state", "expr", "lhs", "rhs", "itemVar", "idxVar", "holder", "cur", "keys", "items", "prevl", "update", "throttle", "_a", "_b", "i", "newItems", "newl", "_change", "s", "_signals", "idx", "subscope", "el", "frag", "core_default", "_prev", "_state", "value", "_", "effect", "parse", "__default", "el", "st", "ex", "name", "v", "attr", "call", "spread_default", "target", "value", "key", "attr", "dashcase", "event_default", "el", "state", "expr", "name", "type", "mods", "evaluate", "parse", "trigger", "decorate", "e", "fn", "call", "sequence_default", "el", "state", "expr", "names", "cur", "off", "steps", "step", "i", "length", "prev", "str", "name", "mods", "evaluate", "parse", "trigger", "decorate", "e", "fn", "call", "_poff", "directive", "el", "state", "expr", "name", "event_default", "__default", "spread_default", "class_default", "text_default", "style_default", "fx_default", "value_default", "ref_default", "scope_default", "if_default", "else_default", "each_default", "dir", "target", "dirName", "mods", "create", "update", "_dispose", "trigger", "decorate", "throttle", "change", "signal", "count", "evaluate", "parse", "_out", "out", "call", "_state", "effect", "modifier", "fn", "_how", "debounce", "e", "_done", "_fn", "_target", "keys", "k", "a", "b", "use", "core_default", "sequence_default", "prev", "str", "start", "p", "s", "signal_exports", "store_default", "package_default", "root", "values", "mutations", "m", "_add", "sprae_default"]
}
