{
  "version": 3,
  "sources": ["../signal.js", "../store.js", "../core.js", "../node_modules/ulive/dist/ulive.es.js", "../directive/if.js", "../directive/each.js", "../directive/ref.js", "../directive/with.js", "../directive/html.js", "../directive/text.js", "../directive/class.js", "../directive/style.js", "../directive/default.js", "../directive/value.js", "../directive/fx.js", "../sprae.js", "../sprae.umd.cjs"],
  "sourcesContent": ["// signals adapter - allows switching signals implementation and not depend on core\nexport let signal, effect, untracked, batch, computed;\n\nexport function use(s) {\n  signal = s.signal\n  effect = s.effect\n  computed = s.computed\n  batch = s.batch || (fn => fn())\n  untracked = s.untracked || batch\n}\n", "// signals-based proxy\nimport { signal, computed, effect, batch, untracked } from './signal.js'\n\nexport const _signals = Symbol('signals'), _change = Symbol('length');\n\n// object store is not lazy\nexport default function store(values, parent) {\n  if (!values) return values\n\n  // ignore existing state as argument\n  if (values[_signals]) return values;\n\n  // redirect for optimized array store\n  if (Array.isArray(values)) return list(values)\n\n  // ignore non-objects\n  if (values.constructor !== Object) return values;\n\n  // NOTE: if you decide to unlazy values, think about large arrays - init upfront can be costly\n  let signals = { ...parent?.[_signals] }, _len = signal(Object.values(values).length)\n\n  // proxy conducts prop access to signals\n  const state = new Proxy(signals, {\n    get: (_, key) => key === _change ? _len : key === _signals ? signals : (signals[key]?.valueOf()),\n    set: (_, key, v, s) => (s = signals[key], set(signals, key, v), s ?? (++_len.value), 1), // bump length for new signal\n    deleteProperty: (_, key) => (signals[key] && (del(signals, key), _len.value--), 1),\n    ownKeys() {\n      // subscribe to length when object is spread\n      _len.value\n      return Reflect.ownKeys(signals);\n    },\n  })\n\n  // init signals for values\n  for (let key in values) {\n    const desc = Object.getOwnPropertyDescriptor(values, key)\n\n    // getter turns into computed\n    if (desc?.get) {\n      // stash setter\n      (signals[key] = computed(desc.get.bind(state)))._set = desc.set?.bind(state);\n    }\n    else {\n      // init blank signal - make sure we don't take prototype one\n      signals[key] = undefined\n      set(signals, key, values[key]);\n    }\n  }\n\n  return state\n}\n\n// length changing methods\nconst mut = { push: 1, pop: 1, shift: 1, unshift: 1, splice: 1 }\n\n// array store - signals are lazy since arrays can be very large & expensive\nexport function list(values) {\n  // track last accessed property to find out if .length was directly accessed from expression or via .push/etc method\n  let lastProp\n\n  // ignore existing state as argument\n  if (values[_signals]) return values;\n\n  // .length signal is stored separately, since it cannot be replaced on array\n  let _len = signal(values.length),\n    // gotta fill with null since proto methods like .reduce may fail\n    signals = Array(values.length).fill();\n\n  // proxy conducts prop access to signals\n  const state = new Proxy(signals, {\n    get(_, key) {\n      // covers Symbol.isConcatSpreadable etc.\n      if (typeof key === 'symbol') return key === _change ? _len : key === _signals ? signals : signals[key]\n\n      // console.log('get', key)\n      // if .length is read within .push/etc - peek signal to avoid recursive subscription\n      if (key === 'length') return mut[lastProp] ? _len.peek() : _len.value;\n\n      lastProp = key;\n\n      if (signals[key]) return signals[key].valueOf()\n\n      // I hope reading values here won't diverge from signals\n      if (key < signals.length) return (signals[key] = signal(store(values[key]))).value\n    },\n\n    set(_, key, v) {\n      // console.log('set', key, v)\n      // .length\n      if (key === 'length') {\n        // force cleaning up tail\n        for (let i = v, l = signals.length; i < l; i++) delete state[i]\n        // .length = N directly\n        _len.value = signals.length = v;\n        return true\n      }\n\n      set(signals, key, v)\n\n      // force changing length, if eg. a=[]; a[1]=1 - need to come after setting the item\n      if (key >= _len.peek()) _len.value = signals.length = Number(key) + 1\n\n      return true\n    },\n\n    deleteProperty: (_, key) => (signals[key] && del(signals, key), 1),\n\n  })\n\n  return state\n}\n\n// set/update signal value\nfunction set(signals, key, v) {\n  let s = signals[key]\n\n  // untracked\n  if (key[0] === '_') signals[key] = v\n  // new property\n  else if (!s) {\n    // preserve signal value as is\n    signals[key] = s = v?.peek ? v : signal(store(v))\n  }\n  // skip unchanged (although can be handled by last condition - we skip a few checks this way)\n  else if (v === s.peek());\n  // stashed _set for value with getter/setter\n  else if (s._set) s._set(v)\n  // patch array\n  else if (Array.isArray(v) && Array.isArray(s.peek())) {\n    const cur = s.peek()\n    // if we update plain array (stored in signal) - take over value instead\n    if (cur[_change]) untracked(() => {\n      batch(() => {\n        let i = 0, l = v.length;\n        for (; i < l; i++) cur[i] = v[i]\n        cur.length = l // forces deleting tail signals\n      })\n    })\n    else {\n      s.value = v\n    }\n  }\n  // .x = y\n  else {\n    s.value = store(v)\n  }\n}\n\n// delete signal\nfunction del(signals, key) {\n  const s = signals[key], del = s[Symbol.dispose]\n  if (del) delete s[Symbol.dispose]\n  delete signals[key]\n  del?.()\n}\n", "import { use } from \"./signal.js\";\nimport store, { _signals } from './store.js';\n\n// polyfill\nconst _dispose = (Symbol.dispose ||= Symbol(\"dispose\"));\n\n// reserved directives - order matters!\nexport const directive = {};\n\n// every element that's in cache === directly spraed and un subsequent sprae is just updated (like each)\nexport const memo = new WeakMap();\n\n// sprae element: apply directives\nexport default function sprae(el, values) {\n  // text nodes, comments etc\n  if (!el?.childNodes) return\n\n  // repeated call can be caused by :each with new objects with old keys needs an update\n  if (memo.has(el)) {\n    // we rewrite signals instead of update, because user should have what he provided\n    return Object.assign(memo.get(el), values)\n  }\n\n  // take over existing state instead of creating clone\n  const state = store(values || {}), disposes = []\n\n  init(el);\n\n  // if element was spraed by :with or :each instruction - skip, otherwise save\n  if (!memo.has(el)) memo.set(el, state);\n\n  // disposer unspraes all internal elements\n  el[_dispose] = () => {\n    while (disposes.length) disposes.pop()();\n    memo.delete(el);\n  }\n\n  return state;\n\n  function init(el, parent = el.parentNode) {\n    if (!el.childNodes) return // ignore text nodes, comments etc\n\n    // init generic-name attributes second\n    for (let i = 0; i < el.attributes?.length;) {\n      let attr = el.attributes[i];\n\n      if (attr.name[0] === ':') {\n        el.removeAttribute(attr.name);\n\n        // multiple attributes like :id:for=\"\"\n        let names = attr.name.slice(1).split(':')\n\n        // NOTE: secondary directives don't stop flow nor extend state, so no need to check\n        for (let name of names) {\n          let dir = directive[name] || directive.default\n          let evaluate = (dir.parse || parse)(attr.value)\n          let dispose = dir(el, evaluate, state, name);\n          if (dispose) disposes.push(dispose);\n        }\n\n        // stop if element was spraed by internal directive\n        if (memo.has(el)) return el[_dispose] && disposes.push(el[_dispose])\n\n        // stop if element is skipped (detached) like in case of :if or :each\n        if (el.parentNode !== parent) return\n      } else i++;\n    }\n\n    for (let child of [...el.childNodes]) init(child, el);\n  };\n}\n\n\n// compiler\nconst evalMemo = {};\nexport const parse = (expr, dir, fn) => {\n  if (fn = evalMemo[expr = expr.trim()]) return fn\n\n  // static-time errors\n  try { fn = compile(expr) }\n  catch (e) { err(e, dir, expr) }\n\n  // runtime errors\n  return evalMemo[expr] = fn\n}\n\n// wrapped call\nexport const err = (e, dir, expr = '') => {\n  throw Object.assign(e, { message: `\u2234 ${e.message}\\n\\n${dir}${expr ? `=\"${expr}\"\\n\\n` : \"\"}`, expr })\n}\n\nexport let compile\n\n// configure signals/compile\n// it's more compact than using sprae.signal = signal etc.\nsprae.use = s => {\n  s.signal && use(s);\n  s.compile && (compile = s.compile);\n}\n\n\n// instantiated <template> fragment holder, like persisting fragment but with minimal API surface\nexport const frag = (tpl) => {\n  if (!tpl.nodeType) return tpl // existing tpl\n\n  let content = tpl.content.cloneNode(true),\n    attributes = [...tpl.attributes],\n    ref = document.createTextNode(''),\n    // ensure at least one node\n    childNodes = (content.append(ref), [...content.childNodes])\n\n  return {\n    childNodes,\n    content,\n    remove: () => content.append(...childNodes),\n    replaceWith(el) {\n      if (el === ref) return\n      ref.before(el)\n      content.append(...childNodes)\n    },\n    attributes,\n    removeAttribute(name) { attributes.splice(attributes.findIndex(a => a.name === name), 1) }\n  }\n}\n", "let current, batched;\r\n\r\nconst signal = (v, s, obs = new Set) => (\r\n  s = {\r\n    get value() {\r\n      current?.deps.push(obs.add(current));\r\n      return v\r\n    },\r\n    set value(val) {\r\n      if (val === v) return\r\n      v = val;\r\n      for (let sub of obs) batched ? batched.add(sub) : sub(); // notify effects\r\n    },\r\n    peek() { return v },\r\n  },\r\n  s.toJSON = s.then = s.toString = s.valueOf = () => s.value,\r\n  s\r\n),\r\n  effect = (fn, teardown, fx, deps) => (\r\n    fx = (prev) => {\r\n      teardown?.call?.();\r\n      prev = current, current = fx;\r\n      try { teardown = fn(); } finally { current = prev; }\r\n    },\r\n    deps = fx.deps = [],\r\n\r\n    fx(),\r\n    (dep) => { teardown?.call?.(); while (dep = deps.pop()) dep.delete(fx); }\r\n  ),\r\n  computed = (fn, s = signal(), c, e) => (\r\n    c = {\r\n      get value() {\r\n        e ||= effect(() => s.value = fn());\r\n        return s.value\r\n      },\r\n      peek: s.peek\r\n    },\r\n    c.toJSON = c.then = c.toString = c.valueOf = () => c.value,\r\n    c\r\n  ),\r\n  batch = (fn) => {\r\n    let fxs = batched;\r\n    if (!fxs) batched = new Set;\r\n    try { fn(); }\r\n    finally {\r\n      if (!fxs) {\r\n        fxs = batched;\r\n        batched = null;\r\n        for (const fx of fxs) fx();\r\n      }\r\n    }\r\n  },\r\n  untracked = (fn, prev, v) => (prev = current, current = null, v = fn(), current = prev, v);\n\nexport { batch, computed, effect, signal, untracked };\n", "import sprae, { directive, memo, frag } from \"../core.js\";\nimport { effect } from \"../signal.js\";\n\n// :if is interchangeable with :each depending on order, :if :each or :each :if have different meanings\n// as for :if :with - :if must init first, since it is lazy, to avoid initializing component ahead of time by :with\n// we consider :with={x} :if={x} case insignificant\nconst _prevIf = Symbol(\"if\");\ndirective.if = (el, evaluate, state) => {\n  let next = el.nextElementSibling,\n    holder = document.createTextNode(''),\n    curEl, ifEl, elseEl;\n\n  el.replaceWith(holder)\n\n  ifEl = el.content ? frag(el) : el\n  memo.set(ifEl, null) // mark all el as fake-spraed, because we have to sprae for real on insert\n\n  if (next?.hasAttribute(\":else\")) {\n    next.removeAttribute(\":else\");\n    // if next is :else :if - leave it for its own :if handler\n    if (!next.hasAttribute(\":if\")) next.remove(), elseEl = next.content ? frag(next) : next, memo.set(elseEl, null)\n  }\n\n  return effect(() => {\n    const newEl = evaluate(state) ? ifEl : el[_prevIf] ? null : elseEl;\n    if (next) next[_prevIf] = newEl === ifEl\n    if (curEl != newEl) {\n      curEl?.remove()\n      if (curEl = newEl) {\n        holder.before(curEl.content || curEl)\n        memo.get(curEl) === null && memo.delete(curEl) // remove fake memo to sprae as new\n        sprae(curEl, state)\n      }\n    }\n  });\n};\n", "import sprae, { directive, frag, parse } from \"../core.js\";\nimport store, { _change, _signals } from \"../store.js\";\nimport { effect, untracked, computed } from '../signal.js';\n\n\ndirective.each = (tpl, [itemVar, idxVar, evaluate], state) => {\n  // we need :if to be able to replace holder instead of tpl for :if :each case\n  const holder = (document.createTextNode(\"\"));\n  tpl.replaceWith(holder);\n\n  // we re-create items any time new items are produced\n  let cur, keys, prevl = 0\n\n  // separate computed effect reduces number of needed updates for the effect\n  const items = computed(() => {\n    keys = null\n    let items = evaluate(state)\n    if (typeof items === \"number\") items = Array.from({ length: items }, (_, i) => i + 1)\n    if (items?.constructor === Object) keys = Object.keys(items), items = Object.values(items)\n    return items || []\n  })\n\n  const update = () => {\n    // NOTE: untracked avoids rerendering full list whenever internal items or props change\n    untracked(() => {\n      let i = 0, newItems = items.value, newl = newItems.length\n\n      // plain array update, not store (signal with array) - updates full list\n      if (cur && !(cur[_change])) {\n        for (let s of cur[_signals] || []) { s[Symbol.dispose]() }\n        cur = null, prevl = 0\n      }\n\n      // delete\n      if (newl < prevl) {\n        cur.length = newl\n      }\n      // update, append, init\n      else {\n        // init\n        if (!cur) {\n          cur = newItems\n        }\n        // update\n        else {\n          for (; i < prevl; i++) {\n            cur[i] = newItems[i]\n          }\n        }\n\n        // append\n        for (; i < newl; i++) {\n          cur[i] = newItems[i]\n          let idx = i,\n            scope = store({\n              [itemVar]: cur[_signals]?.[idx] || cur[idx],\n              [idxVar]: keys ? keys[idx] : idx\n            }, state),\n            el = tpl.content ? frag(tpl) : tpl.cloneNode(true);\n\n          holder.before(el.content || el);\n          sprae(el, scope);\n\n          // signal/holder disposal removes element\n          ((cur[_signals] ||= [])[i] ||= {})[Symbol.dispose] = () => {\n            el[Symbol.dispose](), el.remove()\n          };\n        }\n      }\n\n      prevl = newl\n    })\n  }\n\n  let planned = 0\n  return effect(() => {\n    // subscribe to items change (.length) - we do it every time (not just on init) since preact unsubscribes unused signals\n    items.value[_change]?.value\n\n    // make first render immediately, debounce subsequent renders\n    if (!planned) {\n      update()\n      queueMicrotask(() => (planned && update(), planned = 0))\n    } else planned++\n  })\n}\n\n\n// redefine parser to exclude `[a in] b`\ndirective.each.parse = (expr) => {\n  let [leftSide, itemsExpr] = expr.split(/\\s+in\\s+/);\n  let [itemVar, idxVar = \"$\"] = leftSide.split(/\\s*,\\s*/);\n\n  return [itemVar, idxVar, parse(itemsExpr)]\n}\n", "import { directive } from \"../core.js\";\nimport { _change, _signals } from \"../store.js\";\n\n// ref must be last within primaries, since that must be skipped by :each, but before secondaries\ndirective.ref = (el, expr, state) => {\n  state[expr] = el\n}\n\ndirective.ref.parse = expr => expr\n", "import sprae, { directive } from \"../core.js\";\nimport store, { _signals } from '../store.js';\nimport { effect } from \"../signal.js\";\n\ndirective.with = (el, evaluate, rootState) => {\n  let state\n  return effect(() => {\n    let values = evaluate(rootState);\n    sprae(el, state ? values : state = store(values, rootState))\n  })\n};\n", "import sprae, { directive } from \"../core.js\";\n\ndirective.html = (el, evaluate, state) => {\n  let tpl = evaluate(state);\n\n  if (!tpl) return\n\n  let content = (tpl.content || tpl).cloneNode(true);\n  el.replaceChildren(content);\n  sprae(el, state);\n};\n", "import { directive, frag } from \"../core.js\";\nimport { effect } from \"../signal.js\";\n\n// set text content\ndirective.text = (el, evaluate, state) => {\n  // <template :text=\"a\"/> or previously initialized template\n  if (el.content) el.replaceWith(el = frag(el).childNodes[0])\n\n  return effect(() => {\n    let value = evaluate(state);\n    el.textContent = value == null ? \"\" : value;\n  });\n};\n", "import { directive } from \"../core.js\";\nimport { effect } from \"../signal.js\";\n\ndirective.class = (el, evaluate, state) => {\n  let cur = new Set\n  return effect(() => {\n    let v = evaluate(state);\n    let clsx = new Set;\n    if (v) {\n      if (typeof v === \"string\") v.split(' ').map(cls => clsx.add(cls));\n      else if (Array.isArray(v)) v.map(v => v && clsx.add(v));\n      else Object.entries(v).map(([k, v]) => v && clsx.add(k));\n    }\n    for (let cls of cur) if (clsx.has(cls)) clsx.delete(cls); else el.classList.remove(cls);\n    for (let cls of cur = clsx) el.classList.add(cls)\n  });\n};\n", "import { directive } from \"../core.js\";\nimport { effect } from \"../signal.js\";\n\ndirective.style = (el, evaluate, state) => {\n  let initStyle = el.getAttribute(\"style\");\n\n  return effect(() => {\n    let v = evaluate(state);\n    if (typeof v === \"string\") el.setAttribute(\"style\", initStyle + (initStyle.endsWith(';') ? '' : '; ') + v);\n    else {\n      if (initStyle) el.setAttribute(\"style\", initStyle);\n      for (let k in v) k[0] == '-' ? (el.style.setProperty(k, v[k])) : el.style[k] = v[k]\n    }\n  });\n};\n", "import { directive, err } from \"../core.js\";\nimport { effect } from \"../signal.js\";\n\n// set generic property directive\ndirective.default = (target, evaluate, state, name) => {\n  // simple prop\n  if (!name.startsWith('on')) return effect(() => {\n    let value = evaluate(state);\n    if (name) attr(target, name, value)\n    else for (let key in value) attr(target, dashcase(key), value[key]);\n  });\n\n  // bind event to a target\n  // NOTE: if you decide to remove chain of events, thing again - that's unique feature of sprae, don't diminish your own value.\n  // ona..onb\n  const ctxs = name.split('..').map(e => {\n    let ctx = { evt: '', target, test: () => true };\n    ctx.evt = (e.startsWith('on') ? e.slice(2) : e).replace(/\\.(\\w+)?-?([-\\w]+)?/g,\n      (match, mod, param = '') => (ctx.test = mods[mod]?.(ctx, ...param.split('-')) || ctx.test, '')\n    );\n    return ctx;\n  });\n\n  // single event\n  if (ctxs.length == 1) return effect(() => addListener(evaluate(state), ctxs[0]))\n\n  // events cycler\n  let startFn, nextFn, off, idx = 0\n  const nextListener = (fn) => {\n    off = addListener((e) => (\n      off(), nextFn = fn?.(e), (idx = ++idx % ctxs.length) ? nextListener(nextFn) : (startFn && nextListener(startFn))\n    ), ctxs[idx]);\n  }\n\n  return effect(() => (\n    startFn = evaluate(state),\n    !off && nextListener(startFn),\n    () => startFn = null // nil startFn to autodispose chain\n  ))\n\n  // add listener with the context\n  function addListener(fn, { evt, target, test, defer, stop, prevent, immediate, ...opts }) {\n    if (defer) fn = defer(fn)\n\n    const cb = (e) => {\n      try {\n        test(e) && (stop && (immediate ? e.stopImmediatePropagation() : e.stopPropagation()), prevent && e.preventDefault(), fn?.(e))\n      } catch (error) { err(error, `:on${evt}`, fn) }\n    };\n\n    target.addEventListener(evt, cb, opts)\n    return () => target.removeEventListener(evt, cb, opts)\n  };\n\n};\n\n// event modifiers\nconst mods = {\n  // actions\n  prevent(ctx) { ctx.prevent = true; },\n  stop(ctx) { ctx.stop = true; },\n  immediate(ctx) { ctx.immediate = true; },\n\n  // options\n  once(ctx) { ctx.once = true; },\n  passive(ctx) { ctx.passive = true; },\n  capture(ctx) { ctx.capture = true; },\n\n  // target\n  window(ctx) { ctx.target = window; },\n  document(ctx) { ctx.target = document; },\n\n  throttle(ctx, limit) { ctx.defer = (fn) => throttle(fn, limit ? Number(limit) || 0 : 108); },\n  debounce(ctx, wait) { ctx.defer = (fn) => debounce(fn, wait ? Number(wait) || 0 : 108); },\n\n  // test\n  outside: (ctx) => (e) => {\n    let target = ctx.target;\n    if (target.contains(e.target)) return false;\n    if (e.target.isConnected === false) return false;\n    if (target.offsetWidth < 1 && target.offsetHeight < 1) return false;\n    return true;\n  },\n  self: (ctx) => (e) => e.target === ctx.target,\n\n  // keyboard\n  ctrl: (_, ...param) => (e) => keys.ctrl(e) && param.every((p) => (keys[p] ? keys[p](e) : e.key === p)),\n  shift: (_, ...param) => (e) => keys.shift(e) && param.every((p) => (keys[p] ? keys[p](e) : e.key === p)),\n  alt: (_, ...param) => (e) => keys.alt(e) && param.every((p) => (keys[p] ? keys[p](e) : e.key === p)),\n  meta: (_, ...param) => (e) => keys.meta(e) && param.every((p) => (keys[p] ? keys[p](e) : e.key === p)),\n  // NOTE: we don't expose up/left/right/down as too verbose: can and better be handled/differentiated at once\n  arrow: () => keys.arrow,\n  enter: () => keys.enter,\n  esc: () => keys.esc,\n  tab: () => keys.tab,\n  space: () => keys.space,\n  delete: () => keys.delete,\n  digit: () => keys.digit,\n  letter: () => keys.letter,\n  char: () => keys.char,\n};\n\n// key testers\nconst keys = {\n  ctrl: (e) => e.ctrlKey || e.key === \"Control\" || e.key === \"Ctrl\",\n  shift: (e) => e.shiftKey || e.key === \"Shift\",\n  alt: (e) => e.altKey || e.key === \"Alt\",\n  meta: (e) => e.metaKey || e.key === \"Meta\" || e.key === \"Command\",\n  arrow: (e) => e.key.startsWith(\"Arrow\"),\n  enter: (e) => e.key === \"Enter\",\n  esc: (e) => e.key.startsWith(\"Esc\"),\n  tab: (e) => e.key === \"Tab\",\n  space: (e) => e.key === \"\u00A0\" || e.key === \"Space\" || e.key === \" \",\n  delete: (e) => e.key === \"Delete\" || e.key === \"Backspace\",\n  digit: (e) => /^\\d$/.test(e.key),\n  letter: (e) => /^\\p{L}$/gu.test(e.key),\n  char: (e) => /^\\S$/.test(e.key),\n};\n\n// set attr\nexport const attr = (el, name, v) => {\n  if (v == null || v === false) el.removeAttribute(name);\n  else el.setAttribute(name, v === true ? \"\" : typeof v === \"number\" || typeof v === \"string\" ? v : \"\");\n}\n\n// create delayed fns\nconst throttle = (fn, limit) => {\n  let pause, planned,\n    block = (e) => {\n      pause = true;\n      setTimeout(() => {\n        pause = false;\n        // if event happened during blocked time, it schedules call by the end\n        if (planned) return (planned = false), block(e), fn(e);\n      }, limit);\n    };\n  return (e) => {\n    if (pause) return (planned = true);\n    block(e);\n    return fn(e);\n  };\n};\n\nconst debounce = (fn, wait) => {\n  let timeout;\n  return (e) => {\n    clearTimeout(timeout);\n    timeout = setTimeout(() => {\n      timeout = null;\n      fn(e);\n    }, wait);\n  };\n};\n\nexport const dashcase = (str) => {\n  return str.replace(/[A-Z\\u00C0-\\u00D6\\u00D8-\\u00DE]/g, (match) => \"-\" + match.toLowerCase());\n}\n", "import { directive, parse } from \"../core.js\";\nimport { attr } from './default.js';\nimport { effect } from \"../signal.js\";\n\n// connect expr to element value\ndirective.value = (el, [getValue, setValue], state) => {\n  const update =\n    (el.type === \"text\" || el.type === \"\") ? (value) => el.setAttribute(\"value\", (el.value = value == null ? \"\" : value))\n      : (el.tagName === \"TEXTAREA\" || el.type === \"text\" || el.type === \"\") ? (value, from, to) =>\n      (\n        // we retain selection in input\n        (from = el.selectionStart),\n        (to = el.selectionEnd),\n        el.setAttribute(\"value\", (el.value = value == null ? \"\" : value)),\n        from && el.setSelectionRange(from, to)\n      )\n        : (el.type === \"checkbox\") ? (value) => (el.checked = value, attr(el, \"checked\", value))\n          : (el.type === \"select-one\") ? (value) => {\n            for (let option in el.options) option.removeAttribute(\"selected\");\n            el.value = value;\n            el.selectedOptions[0]?.setAttribute(\"selected\", \"\");\n          }\n            : (value) => (el.value = value);\n\n  // bind back\n  const handleChange = el.type === 'checkbox' ? e => setValue(state, el.checked) : e => setValue(state, el.value)\n  el.addEventListener('input', handleChange)\n  el.addEventListener('change', handleChange)\n\n  return effect(() => (update(getValue(state))));\n};\n\ndirective.value.parse = expr => {\n  let evaluate = [parse(expr)]\n  try {\n    // for values like `123 = arguments[1]`, `foo?.bar = arguments[1]`\n    evaluate.push(parse(`${expr}=arguments[1];`))\n  }\n  catch (e) { }\n  return evaluate\n}\n", "import { directive } from \"../core.js\";\nimport { effect } from \"../signal.js\";\n\ndirective.fx = (el, evaluate, state) => {\n  return effect(() => evaluate(state));\n};\n", "import sprae from './core.js'\n\nimport * as signals from 'ulive'\n\n// default directives\nimport './directive/if.js'\nimport './directive/each.js'\nimport './directive/ref.js'\nimport './directive/with.js'\nimport './directive/html.js'\nimport './directive/text.js'\nimport './directive/class.js'\nimport './directive/style.js'\nimport './directive/value.js'\nimport './directive/fx.js'\nimport './directive/default.js'\n\n// default signals\nsprae.use(signals)\n\n// default compiler (indirect new Function to avoid detector)\nsprae.use({ compile: expr => sprae.constructor(`with (arguments[0]) { return ${expr} };`) })\n\nexport default sprae\n", "import { default as sprae } from \"./sprae.js\";\n\nmodule.exports = sprae;\n\nif (typeof document !== \"undefined\" && document?.currentScript?.hasAttribute(\"init\")) sprae(document.documentElement);"],
  "mappings": "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",
  "names": ["signal", "effect", "untracked", "batch", "computed", "use", "s", "fn", "_signals", "_change", "store", "values", "parent", "list", "signals", "_len", "signal", "state", "_", "key", "v", "s", "set", "del", "desc", "computed", "mut", "lastProp", "i", "l", "cur", "untracked", "batch", "_dispose", "directive", "memo", "sprae", "el", "values", "state", "store", "disposes", "init", "parent", "i", "attr", "names", "name", "dir", "evaluate", "parse", "dispose", "child", "evalMemo", "expr", "fn", "compile", "e", "err", "s", "use", "frag", "tpl", "content", "attributes", "ref", "childNodes", "a", "ulive_es_exports", "__export", "batch", "computed", "effect", "signal", "untracked", "current", "batched", "v", "s", "obs", "val", "sub", "fn", "teardown", "fx", "deps", "prev", "dep", "c", "e", "fxs", "_prevIf", "directive", "el", "evaluate", "state", "next", "holder", "curEl", "ifEl", "elseEl", "frag", "memo", "effect", "newEl", "sprae", "directive", "tpl", "itemVar", "idxVar", "evaluate", "state", "holder", "cur", "keys", "prevl", "items", "computed", "_", "i", "update", "untracked", "_a", "_b", "newItems", "newl", "_change", "s", "_signals", "idx", "scope", "store", "el", "frag", "sprae", "planned", "effect", "expr", "leftSide", "itemsExpr", "parse", "directive", "el", "expr", "state", "directive", "el", "evaluate", "rootState", "state", "effect", "values", "sprae", "store", "directive", "el", "evaluate", "state", "tpl", "content", "sprae", "directive", "el", "evaluate", "state", "frag", "effect", "value", "directive", "el", "evaluate", "state", "cur", "effect", "v", "clsx", "cls", "k", "directive", "el", "evaluate", "state", "initStyle", "effect", "v", "k", "directive", "target", "evaluate", "state", "name", "effect", "value", "attr", "key", "dashcase", "ctxs", "e", "ctx", "match", "mod", "param", "mods", "addListener", "startFn", "nextFn", "off", "idx", "nextListener", "fn", "evt", "test", "defer", "stop", "prevent", "immediate", "opts", "cb", "error", "err", "limit", "throttle", "wait", "debounce", "_", "keys", "p", "el", "v", "pause", "planned", "block", "timeout", "str", "directive", "el", "getValue", "setValue", "state", "update", "value", "from", "to", "attr", "option", "handleChange", "e", "effect", "expr", "evaluate", "parse", "directive", "el", "evaluate", "state", "effect", "sprae", "ulive_es_exports", "expr", "sprae_default", "sprae_default"]
}
