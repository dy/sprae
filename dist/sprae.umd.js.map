{
  "version": 3,
  "sources": ["../package.json", "../core.js", "../store.js", "../signal.js", "../directive/if.js", "../directive/else.js", "../directive/text.js", "../directive/class.js", "../directive/style.js", "../directive/fx.js", "../directive/value.js", "../directive/ref.js", "../directive/scope.js", "../directive/each.js", "../directive/default.js", "../directive/spread.js", "../sprae.js", "<stdin>"],
  "sourcesContent": ["{\n  \"name\": \"sprae\",\n  \"description\": \"DOM microhydration\",\n  \"version\": \"12.2.0\",\n  \"main\": \"./sprae.js\",\n  \"module\": \"./sprae.js\",\n  \"umd:main\": \"dist/sprae.umd.js\",\n  \"unpkg\": \"dist/sprae.umd.js\",\n  \"types\": \"dist/sprae.d.ts\",\n  \"type\": \"module\",\n  \"files\": [\n    \"core.js\",\n    \"sprae.js\",\n    \"store.js\",\n    \"signal.js\",\n    \"micro.js\",\n    \"directive\",\n    \"dist\"\n  ],\n  \"devDependencies\": {\n    \"@preact/signals\": \"^2.0.4\",\n    \"@preact/signals-core\": \"^1.8.0\",\n    \"@webreflection/signal\": \"^2.1.2\",\n    \"es-module-shims\": \"^1.10.0\",\n    \"esbuild\": \"^0.23.0\",\n    \"esbuild-plugin-umd-wrapper\": \"^2.0.3\",\n    \"hyperf\": \"^1.7.0\",\n    \"jsdom\": \"^27.0.0\",\n    \"requestidlecallback\": \"^0.3.0\",\n    \"signal-polyfill\": \"^0.1.1\",\n    \"subscript\": \"^9.1.0\",\n    \"tst\": \"^7.2.0\",\n    \"ulive\": \"^1.0.7\",\n    \"usignal\": \"^0.9.0\",\n    \"wait-please\": \"^3.1.0\"\n  },\n  \"scripts\": {\n    \"test\": \"node -r ./test/register.cjs test/test.js\",\n    \"build\": \"node .esbuild.js\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/dy/sprae.git\"\n  },\n  \"keywords\": [\n    \"hydration\",\n    \"progressive\",\n    \"progressive enhancement\",\n    \"signals\",\n    \"directives\",\n    \"preact-signals\",\n    \"reactive\",\n    \"template-parts\",\n    \"petit-vue\",\n    \"alpinejs\",\n    \"templating\"\n  ],\n  \"author\": \"Dmitry Iv <df.creative@gmail.com>\",\n  \"license\": \"MIT\",\n  \"bugs\": {\n    \"url\": \"https://github.com/dy/sprae/issues\"\n  },\n  \"homepage\": \"https://github.com/dy/sprae#readme\"\n}\n", "import store, { _change, _signals } from \"./store.js\";\nimport pkg from './package.json' with { type: 'json' };\n\nexport const _dispose = (Symbol.dispose ||= Symbol(\"dispose\")),\n  _state = Symbol(\"state\"),\n  _on = Symbol('on'),\n  _off = Symbol('off'),\n  _add = Symbol('add');\n\n\nexport let prefix = ':', signal, effect, computed, batch = (fn) => fn(), untracked = batch;\n\nexport let directive = {}, modifier = {}\n\nlet currentDir = null;\n\n/**\n * Applies directives to an HTML element and manages its reactive state.\n *\n * @param {Element} [el=document.body] - The target HTML element to apply directives to.\n * @param {Object|store} [state] - Initial state values to populate the element's reactive state.\n * @returns {Object} The reactive state object associated with the element.\n */\nconst sprae = (el = document.body, state) => {\n  // repeated call can be caused by eg. :each with new objects with old keys\n  if (el[_state]) return Object.assign(el[_state], state)\n\n  // console.group('sprae', el)\n\n  // take over existing state instead of creating a clone\n  state = store(state || {})\n\n  let fx = [], offs = [], fn,\n    on = () => (!offs && (offs = fx.map(fn => fn()))),\n    off = () => (offs?.map(off => off()), offs = null)\n\n  // on/off all effects\n  // we don't call prevOn as convention: everything defined before :else :if won't be disabled by :if\n  // imagine <x :onx=\"...\" :if=\"...\"/> - when :if is false, it disables directives after :if (calls _off) but ignores :onx\n  el[_on] = on\n  el[_off] = off\n\n  // destroy\n  el[_dispose] ||= () => (el[_off](), el[_off] = el[_on] = el[_dispose] = el[_state] = el[_add] = null)\n\n  const add = (el, _attrs = el.attributes) => {\n    // we iterate live collection (subsprae can init args)\n    if (_attrs) for (let i = 0; i < _attrs.length;) {\n      let { name, value } = _attrs[i]\n\n      if (name.startsWith(prefix)) {\n        el.removeAttribute(name)\n\n        // directive initializer can be redefined\n        if (fn = initDirective(el, name, value, state)) fx.push(fn), offs.push(fn())\n\n        // stop after subsprae like :each, :if, :scope etc.\n        if (_state in el) return\n      } else i++\n    }\n\n    // :if and :each replace element with text node, which tweaks .children length, but .childNodes length persists\n    // for (let i = 0, child; i < (el.childNodes.length); i++) child =  el.childNodes[i], child.nodeType == 1 && add(child)\n    for (let child of [...el.childNodes]) child.nodeType == 1 && add(child)\n  };\n\n  el[_add] = add;\n\n  add(el);\n\n  // if element was spraed by inline :with/:if/:each/etc instruction (meaning it has state placeholder) - skip, otherwise save _state\n  if (el[_state] === undefined) el[_state] = state\n\n  // console.groupEnd()\n\n  return state;\n}\n\nsprae.version = pkg.version;\n\n/**\n * Initializes directive (defined by sprae build), returns \"on\" function that enables it\n * Multiprop sequences initializer, eg. :a:b..c:d\n * @type {(el: HTMLElement, name:string, value:string, state:Object) => Function}\n * */\nconst initDirective = (el, dirName, expr, state) => {\n  let cur, // current step callback\n    off // current step disposal\n\n  let steps = dirName.slice(prefix.length).split('..').map((step, i, { length }) => (\n    // multiple attributes like :id:for=\"\"\n    step.split(prefix).reduce((prev, str) => {\n      let [name, ...mods] = str.split('.');\n      let evaluate = parse(expr, directive[currentDir = name]?.parse)\n\n      // a hack, but events have no signal-effects and can be sequenced\n      // FIXME: events are molded into core, but should be an optional directive\n      if (name.startsWith('on')) {\n        let type = name.slice(2),\n          fn = applyMods(\n            sx(\n              // single event vs chain\n              length == 1 ?  e => evaluate(state, (fn) => call(fn, e)) :\n                (e => (cur = (!i ?  e => call(evaluate(state), e) : cur)(e), off(), off = steps[(i + 1) % length]())),\n              { target: el }\n            ),\n            mods);\n\n        return (_poff) => (_poff = prev?.(), fn.target.addEventListener(type, fn, fn), () => (_poff?.(), fn.target.removeEventListener(type, fn)))\n      }\n\n      let fn, dispose, change, count;\n\n      if (mods.length) {\n        change = signal(-1), // signal authorized to trigger effect: 0 = init; >0 = trigger\n        count = -1 // called effect count\n\n        // effect applier - first time it applies the effect, next times effect is triggered by change signal\n        fn = applyMods(sx(throttle(() => {\n            if (++change.value) return // all calls except for the first one are handled by effect\n            dispose = effect(() => update && (\n              change.value == count ? fn() : // plan update: separate tick (via throttle) makes sure planner effect call is finished before eval call\n                (count = change.value, evaluate(state, update)) // if changed more than effect called - call it\n            ));\n          }), {target: el}), mods)\n      }\n      else {\n        fn = sx(() => dispose = effect(() =>  evaluate(state, update)), {target: el })\n      }\n\n      // props have no sequences and can be sync\n      // it's nice to see directive as taking some part of current context and returning new or updated context\n      let update = (directive[name] || directive['*'])(fn.target, state, expr, name)\n\n      // some directives are effect-less\n      if (!update) return\n\n      // take over state if directive created it (mainly :scope)\n      if (el[_state]) state = el[_state]\n\n      return (_poff) => (\n        _poff = prev?.(),\n        // console.log('ON', name),\n        fn(),\n        () => (\n          // console.log('OFF', name, el),\n          _poff?.(), dispose?.(), change && (change.value = -1, count = dispose = null)\n        )\n      )\n    }, null)\n  ));\n\n  // off can be changed on the go\n  return () => (off = steps[0]?.())\n}\n\n\n/**\n * Configure sprae\n */\nexport const use = (s) => (\n  s.compile && (compile = s.compile),\n  s.prefix && (prefix = s.prefix),\n  s.signal && (signal = s.signal),\n  s.effect && (effect = s.effect),\n  s.computed && (computed = s.computed),\n  s.batch && (batch = s.batch),\n  s.untracked && (untracked = s.untracked)\n)\n\n\n/**\n * Lifecycle hanger: spraes automatically any new nodes\n */\nexport const start = (root = document.body, values) => {\n  const state = store(values);\n  sprae(root, state);\n  const mo = new MutationObserver(mutations => {\n    for (const m of mutations) {\n      for (const el of m.addedNodes) {\n        // el can be spraed or removed by subsprae (like within :each/:if)\n        if (el.nodeType === 1 && el[_state] === undefined && el.isConnected) {\n          for (const attr of el.attributes) {\n            if (attr.name.startsWith(prefix)) {\n              root[_add](el); break;\n            }\n          }\n        }\n      }\n      // for (const el of m.removedNodes) el[Symbol.dispose]?.()\n    }\n  });\n  mo.observe(root, { childList: true, subtree: true });\n  return state\n}\n\n\n/**\n * Compiles an expression into an evaluator function.\n * @type {(dir:string, expr: string, clean?: string => string) => Function}\n */\nexport let compile\n\n/**\n * Parses an expression into an evaluator function, caching the result for reuse.\n *\n * @param {string} expr The expression to parse and compile into a function.\n * @returns {Function} The compiled evaluator function for the expression.\n */\nexport const parse = (expr, prepare, _fn) => {\n  if (_fn = parse.cache[expr]) return _fn\n\n  let _expr = expr.trim() || 'undefined'\n  if (prepare) _expr = prepare(_expr)\n\n  // if, const, let - no return\n  if (/^(if|let|const)\\b/.test(_expr) || /;(?![^{]*})/.test(_expr)) ;\n  else _expr = `return ${_expr}`\n\n  // async expression\n  if (/\\bawait\\s/.test(_expr)) _expr = `return (async()=>{ ${_expr} })()`\n\n  // static time errors\n  try {\n    _fn = compile(_expr)\n    Object.defineProperty(_fn, \"name\", {value: `\u2234 ${expr}`})\n  } catch (e) { console.error(`\u2234 ${e}\\n\\n${prefix + currentDir}=\"${expr}\"`) }\n\n  // run time errors\n  return parse.cache[expr] = (state, cb, _out) => {\n    try {\n      let result = _fn?.(state)\n      // if cb is given (to handle asyncs) - call it with result and return function that returns last cb result - needed for effect cleanup\n      if (cb) return result?.then ? result.then(v => _out = cb(v)) : _out = cb(result), () => call(_out)\n      else return result\n    } catch (e) {\n      console.error(`\u2234 ${e}\\n\\n${prefix + currentDir}=\"${expr}\"`)\n    }\n  }\n}\nparse.cache = {};\n\n\n// apply modifiers to context (from the end due to nature of wrapping ctx.call)\nconst applyMods = (fn, mods) => {\n  while (mods.length) {\n    let [name, ...params] = mods.pop().split('-')\n    fn = sx(modifier[name]?.(fn, ...params) ?? fn, fn)\n  }\n  return fn\n}\n\n// soft-extend missing props and ignoring signals\nconst sx = (a, b) => { if (a != b) for (let k in b) (a[k] ??= b[k]); return a }\n\n// instantiated <template> fragment holder, like persisting fragment but with minimal API surface\nexport const frag = (tpl) => {\n  if (!tpl.nodeType) return tpl // existing tpl\n\n  let content = tpl.content.cloneNode(true), // document fragment holder of content\n    attributes = [...tpl.attributes],\n    ref = document.createTextNode(''),\n    // ensure at least one node\n    childNodes = (content.append(ref), [...content.childNodes])\n\n  return {\n    // get parentNode() { return childNodes[0].parentNode },\n    childNodes,\n    content,\n    remove: () => content.append(...childNodes),\n    replaceWith(el) {\n      if (el === ref) return\n      ref.before(el)\n      content.append(...childNodes)\n    },\n    attributes,\n    removeAttribute(name) { attributes.splice(attributes.findIndex(a => a.name === name), 1) },\n    // setAttributeNode() { }\n  }\n}\n\n// if value is function - return result of its call\nexport const call = (v, arg) => typeof v === 'function' ? v(arg) : v\n\n// camel to kebab\nexport const dashcase = (str) => str.replace(/[A-Z\\u00C0-\\u00D6\\u00D8-\\u00DE]/g, (match, i) => (i ? '-' : '') + match.toLowerCase());\n\n// set attr\nexport const attr = (el, name, v) => (v == null || v === false) ? el.removeAttribute(name) : el.setAttribute(name, v === true ? \"\" : v);\n\n// convert any-arg to className string\nexport const clsx = (c, _out = []) => !c ? '' : typeof c === 'string' ? c : (\n  Array.isArray(c) ? c.map(clsx) :\n    Object.entries(c).reduce((s, [k, v]) => !v ? s : [...s, k], [])\n).join(' ')\n\n// throttle function to (once per tick or other custom scheduler)\nexport const throttle = (fn, schedule = queueMicrotask) => {\n  let _planned = 0;\n  const throttled = (e) => {\n    if (!_planned++) fn(e), schedule((_dirty = _planned > 1) => (\n      _planned = 0, _dirty && throttled(e)\n    ));\n  }\n  return throttled;\n}\n\nexport const debounce = (fn, schedule = queueMicrotask, _count = 0) => (arg, _planned=++_count) => schedule(() => (_planned == _count && fn(arg)))\n\nexport * from './store.js';\n\nexport default sprae\n", "// signals-based proxy\nimport { signal, computed, batch, untracked, _add } from './core.js'\n\n\n// _signals allows both storing signals and checking instance, which would be difficult with WeakMap\nexport const _signals = Symbol('signals'),\n  // _change is a signal that tracks changes to the object keys or array length\n  _change = Symbol('change'),\n  // _set is stashed setter for computed values\n  _set = Symbol('set')\n\n// a hack to simulate sandbox for `with` in evaluator\nlet sandbox = true\n\n// object store is not lazy\n// parent defines parent scope or sandbox\nexport const store = (values, parent) => {\n  if (!values) return values\n\n  // ignore globals\n  // FIXME: handle via has trap\n  if (values[Symbol.toStringTag]) return values;\n\n  // bypass existing store\n  if (values[_signals]) return values\n\n  // non-objects: for array redirect to list\n  if (values.constructor !== Object) return Array.isArray(values) ? list(values) : values\n\n  // _change stores total number of keys to track new props\n  let keyCount = Object.keys(values).length,\n    signals = {}\n\n  // proxy conducts prop access to signals\n  let state = new Proxy(Object.assign(signals, {\n    [_change]: signal(keyCount),\n    [_signals]: signals\n  }), {\n    get: (_, k) => {\n      // console.log('GET', k, signals)\n      if (k in signals) return (signals[k] ? signals[k].valueOf() : signals[k])\n      return parent ? parent[k] : globalThis[k]\n    },\n\n    set: (_, k, v, _s) => {\n      // console.group('SET', k, v, signals, k in signals)\n      if (k in signals) return set(signals, k, v), 1\n\n      // turn off sandbox to check if parents have the prop - we don't want to create new prop in global scope\n      sandbox = false\n\n      // write transparency for parent scope, unlike prototype chain\n      // if prop is defined in parent scope (except global) - write there\n      if (parent && k in parent) {\n        parent[k] = v\n      }\n      // else create in current scope\n      else {\n        create(signals, k, v)\n        signals[_change].value = ++keyCount\n      }\n\n      sandbox = true\n\n      // console.groupEnd()\n      // bump length for new signal\n      return 1\n    },\n\n    // FIXME: try to avild calling Symbol.dispose here. Maybe _delete method?\n    deleteProperty: (_, k) => {\n      k in signals && (k[0] != '_' && signals[k]?.[Symbol.dispose]?.(), delete signals[k], signals[_change].value = --keyCount)\n      return 1\n    },\n\n    // subscribe to length when spreading\n    ownKeys: () => (signals[_change].value, Reflect.ownKeys(signals)),\n\n    // sandbox prevents writing to global\n    has: (_, k) => {\n      if (k in signals) return true\n      if (parent) return k in parent\n      return sandbox\n    }\n  })\n\n  // init signals for values\n  const descs = Object.getOwnPropertyDescriptors(values)\n\n  for (let k in values) {\n    // getter turns into computed\n    if (descs[k]?.get)\n      // stash setter\n      (signals[k] = computed(descs[k].get.bind(state)))[_set] = descs[k].set?.bind(state);\n\n    // init blank signal - make sure we don't take prototype one\n    else create(signals, k, values[k])\n  }\n\n  return state\n}\n\n// array store - signals are lazy since arrays can be very large & expensive\nconst list = (values, parent = globalThis) => {\n\n  // gotta fill with null since proto methods like .reduce may fail\n  let signals = Array(values.length).fill(null),\n\n    // if .length was accessed from mutator (.push/etc) method\n    isMut = false,\n\n    // since array mutator methods read .length internally only once, we disable it on the moment of call, allowing rest of operations to be reactive\n    mut = fn => function () { isMut = true; return fn.apply(this, arguments); },\n\n    length = signal(values.length),\n\n    // proxy passes prop access to signals\n    state = new Proxy(\n      Object.assign(signals, {\n        [_change]: length,\n        [_signals]: signals,\n        // patch mutators\n        push: mut(signals.push),\n        pop: mut(signals.pop),\n        shift: mut(signals.shift),\n        unshift: mut(signals.unshift),\n        splice: mut(signals.splice),\n      }),\n      {\n        get(_, k) {\n          // console.log('GET', k, isMut)\n\n          // if .length is read within mutators - peek signal to avoid recursive subscription\n          // we need to ignore it only once and keep for the rest of the mutator call\n          if (k === 'length') return isMut ? (isMut = false, signals.length) : length.value;\n\n          // non-numeric\n          if (typeof k === 'symbol' || isNaN(k)) return signals[k]?.valueOf() ?? parent[k];\n\n          // create signal (lazy)\n          // NOTE: if you decide to unlazy values, think about large arrays - init upfront can be costly\n          return (signals[k] ??= signal(store(values[k]))).valueOf()\n        },\n\n        set(_, k, v) {\n          // console.log('SET', k, v)\n\n          // .length\n          if (k === 'length') {\n            // force cleaning up tail\n            for (let i = v; i < signals.length; i++) delete state[i]\n            // .length = N directly\n            length.value = signals.length = v;\n          }\n\n          // force changing length, if eg. a=[]; a[1]=1 - need to come after setting the item\n          else if (k >= signals.length) create(signals, k, v), state.length = +k + 1\n\n          // existing signal\n          else signals[k] ? set(signals, k, v) : create(signals, k, v)\n\n          return 1\n        },\n\n        // dispose notifies any signal deps, like :each\n        deleteProperty: (_, k) => (signals[k]?.[Symbol.dispose]?.(), delete signals[k], 1),\n      })\n\n  return state\n}\n\n// create signal value, skip untracked\nconst create = (signals, k, v) => (signals[k] = (k[0] == '_' || v?.peek) ? v : signal(store(v)))\n\n// set/update signal value\nconst set = (signals, k, v, _s, _v) => {\n  // skip unchanged (although can be handled by last condition - we skip a few checks this way)\n  return k[0] === '_' ? (signals[k] = v) :\n    (v !== (_v = (_s = signals[k]).peek())) && (\n      // stashed _set for value with getter/setter\n      _s[_set] ? _s[_set](v) :\n        // patch array\n        Array.isArray(v) && Array.isArray(_v) ?\n          // if we update plain array (stored in signal) - take over value instead\n          // since input value can be store, we have to make sure we don't subscribe to its length or values\n          // FIXME: generalize to objects\n          _change in _v ?\n            untracked(() => batch(() => {\n              for (let i = 0; i < v.length; i++) _v[i] = v[i]\n              _v.length = v.length // forces deleting tail signals\n            })) :\n            (_s.value = v) :\n          // .x = y\n          (_s.value = store(v))\n    )\n}\n\n\n// make sure state contains first element of path, eg. `a` from `a.b[c]`\n// NOTE: we don't need since we force proxy sandbox\n// export const ensure = (state, expr, _name = expr.match(/^\\w+(?=\\s*(?:\\.|\\[|$))/)) => _name && (state[_signals][_name[0]] ??= null)\n\nexport default store\n", "// preact-signals minimal implementation\nlet current, depth = 0, batched;\n\n// default signals impl\n\nexport const signal = (v, _s, _obs = new Set, _v = () => _s.value) => (\n  _s = {\n    get value() {\n      current?.deps.push(_obs.add(current));\n      return v\n    },\n    set value(val) {\n      if (val === v) return\n      v = val;\n      for (let sub of _obs) batched ? batched.add(sub) : sub(); // notify effects\n    },\n    peek() { return v },\n    toJSON: _v, then: _v, toString: _v, valueOf: _v\n  }\n)\n\nexport const effect = (fn, _teardown, _fx, _deps, __tmp) => (\n  _fx = (prev) => {\n    __tmp = _teardown;\n    _teardown = null; // we null _teardown to avoid repeated call in case of recursive update\n    __tmp?.call?.();\n    prev = current, current = _fx\n    if (depth++ > 10) throw 'Cycle detected';\n    try { _teardown = fn(); } finally { current = prev; depth-- }\n  },\n  _deps = _fx.deps = [],\n\n  _fx(),\n  (dep) => { _teardown?.call?.(); while (dep = _deps.pop()) dep.delete(_fx); }\n)\n\nexport const computed = (fn, _s = signal(), _c, _e, _v = () => _c.value) => (\n  _c = {\n    get value() {\n      _e ||= effect(() => _s.value = fn());\n      return _s.value\n    },\n    peek: _s.peek,\n    toJSON: _v, then: _v, toString: _v, valueOf: _v\n  }\n)\n\nexport const batch = (fn, _first = !batched) => {\n  batched ??= new Set;\n  try { fn(); }\n  finally { if (_first) { for (const fx of batched) fx(); batched = null } }\n}\n\nexport const untracked = (fn, _prev, _v) => (_prev = current, current = null, _v = fn(), current = _prev, _v)\n", "// \"centralized\" version of :if\nimport sprae, { throttle, _on, _off, _state, frag } from '../core.js';\n\n// :if=\"a\"\nexport default (el, state, _holder, _el, _match) => {\n  // new element :if\n  // console.log(':if init', el)\n  if (!el._holder) {\n    // mark el as fake-spraed to delay init, since we sprae rest when branch matches, both :if and :else :if\n    el[_state] ??= null\n\n    _el = el.content ? frag(el) : el\n\n    el.replaceWith(_holder = document.createTextNode(''))\n    _el._holder = _holder._holder = _holder\n\n\n    _holder._clauses = [_el._clause = [_el, false]]\n\n    _holder.update = throttle(() => {\n      let match = _holder._clauses.find(([, s]) => s)\n      // console.group(':if update clauses', ..._holder._clauses)\n\n      if (match != _match) {\n        // console.log(':if match', match)\n        _match?.[0].remove()\n        _match?.[0][_off]?.()\n        if (_match = match) {\n          _holder.before(_match[0].content || _match[0])\n          // there's no :else after :if, so lazy-sprae here doesn't risk adding own destructor to own list of destructors\n          !_match[0][_state] ? (delete _match[0][_state], sprae(_match[0], state)) : _match[0][_on]?.()\n        }\n      }\n      // console.groupEnd()\n    })\n  }\n  // :else :if needs to be spraed all over to have clean list of offable effects\n  else sprae(_el = el, state)\n\n  // :else may have children to init which is called after :if\n  // or preact can schedule :else after :if, so we ensure order of call by next tick\n  return value => {\n    // console.log(':if update', _el, value)\n    _el._clause[1] = value\n    _el._holder.update()\n  }\n}\n", "import { _on, _off, _state, frag } from '../core.js';\n\n\n// NOTE: we can reach :else counterpart whereas prev :else :if is on hold\nexport default (el, state, _el, _, _prev=el) => {\n\n  // console.log(':else init', el)\n  _el = el.content ? frag(el) : el\n\n  // find holder\n  while (_prev && !(_el._holder = _prev._holder)) _prev = _prev.previousSibling\n\n  el.remove()\n  el[_state] = null // mark as fake-spraed to stop further init, to lazy-sprae when branch matches\n\n  _el._holder._clauses.push(_el._clause = [_el, true])\n\n  return _el._holder.update\n}\n", "import { frag, call } from \"../core.js\"\n\nexport default el => (\n  // <template :text=\"a\"/> or previously initialized template\n  el.content && el.replaceWith(el = frag(el).childNodes[0]),\n  v => (v = call(v, el.textContent), el.textContent = v == null ? \"\" : v)\n)\n", "import { clsx, call } from \"../core.js\";\n\nexport default (el, _cur, _new) => (\n  _cur = new Set,\n  (v) => {\n    _new = new Set\n    if (v) clsx(call(v, el.className)).split(' ').map(c => c && _new.add(c))\n    for (let c of _cur) if (_new.has(c)) _new.delete(c); else el.classList.remove(c);\n    for (let c of _cur = _new) el.classList.add(c)\n  }\n)\n", "import { call, attr } from \"../core.js\";\n\nexport default (el, _static) => (\n  _static = el.getAttribute(\"style\"),\n  v => {\n    v = call(v, el.style)\n    if (typeof v === \"string\") attr(el, \"style\", _static + '; ' + v);\n    else {\n      if (_static) attr(el, \"style\", _static);\n      // NOTE: we skip names not starting with a letter - eg. el.style stores properties as { 0: --x } or JSDOM has _pfx\n      for (let k in v) k[0] == '-' ? el.style.setProperty(k, v[k]) : k[0] > 'A' && (el.style[k] = v[k])\n    }\n  }\n)\n", "import { call } from \"../core.js\"\n\nexport default () => call\n", "import sprae, { attr, parse, _state } from \"../core.js\";\n\n\n// create expression setter, reflecting value back to state\nexport const setter = (expr, _set = parse(`${expr}=__`)) => (target, value) => {\n  // save value to stash\n  target.__ = value; _set(target), delete target.__\n}\n\nexport default (el, state, expr, name) => {\n  // bind back to value, but some values can be not bindable, eg. `:value=\"7\"`\n  try {\n    const set = setter(expr)\n    const handleChange = el.type === 'checkbox' ? () => set(state, el.checked) :\n      el.type === 'select-multiple' ? () => set(state, [...el.selectedOptions].map(o => o.value)) :\n        () => set(state, el.selectedIndex < 0 ? null : el.value)\n\n    el.oninput = el.onchange = handleChange; // hope user doesn't redefine these manually via `.oninput = somethingElse` - it saves 5 loc vs addEventListener\n\n    if (el.type?.startsWith('select')) {\n      // select element also must observe any added/removed options or changed values (outside of sprae)\n      new MutationObserver(handleChange).observe(el, { childList: true, subtree: true, attributes: true });\n\n      // select options must be initialized before calling an update\n      sprae(el, state)\n    }\n\n    // initial state value - setter has already cached it, no need to parse again\n    parse(expr)(state) ?? handleChange()\n  } catch { }\n\n  return (el.type === \"text\" || el.type === \"\") ?\n    (value) => el.setAttribute(\"value\", (el.value = value == null ? \"\" : value)) :\n    (el.tagName === \"TEXTAREA\" || el.type === \"text\" || el.type === \"\") ?\n      (value, from, to) => (\n        // we retain selection in input\n        (from = el.selectionStart),\n        (to = el.selectionEnd),\n        el.setAttribute(\"value\", (el.value = value == null ? \"\" : value)),\n        from && el.setSelectionRange(from, to)\n      ) :\n      (el.type === \"checkbox\") ?\n        (value) => (el.checked = value, attr(el, \"checked\", value)) :\n        (el.type === 'radio') ? (value) => (\n          el.value === value && ((el.checked = value), attr(el, 'checked', value))\n        ) :\n          (el.type === \"select-one\") ?\n            (value) => {\n              for (let o of el.options)\n                o.value == value ? o.setAttribute(\"selected\", '') : o.removeAttribute(\"selected\");\n              el.value = value;\n            } :\n            (el.type === 'select-multiple') ? (value) => {\n              for (let o of el.options) o.removeAttribute('selected')\n              for (let v of value) el.querySelector(`[value=\"${v}\"]`).setAttribute('selected', '')\n            } :\n              (value) => (el.value = value);\n}\n", "import { parse } from \"../core.js\"\n// import { setter } from \"./value.js\"\n\nexport default (el, state, expr, name, _prev, _set) => {\n  // FIXME: we call eval twice here - once to check if it's fn, second for update (from core)\n  if (typeof parse(expr)(state) == 'function') return v => (v(el))\n\n  // NOTE: we have to set element statically (outside of effect) to avoid parasitic sub - multiple els with same :ref can cause recursion (eg. :each :ref=\"x\")\n  // (setter(expr)(state, el))\n  Object.defineProperty(state, expr, { value: el, configurable: true })\n}\n", "import sprae, { store, call, untracked, _state, _signals, signal } from '../core.js'\n\nexport default (el, rootState) => {\n  // 0 run pre-creates state to provide scope for the first effect - it can write vars in it, so we should already have it\n  // el[_state] even replaces own :scope effect state\n  let subscope = el[_state] = store({}, rootState), init = false;\n\n  // 1st run spraes subtree with values from scope - it can be postponed by modifiers (we isolate reads from parent effect)\n  // 2nd+ runs update subscope\n  return values => {\n    values = call(values, subscope);\n\n    // we bind to subscope to alleviate friction using scope method directly\n    // also returned props should force-create signals in subscope, not overwriting parent\n    if (values !== subscope) {\n      for (let k in values) {\n        // _add forces new prop, instead of checking parent\n        let v = typeof values[k] === 'function' ? values[k].bind(subscope) : values[k]\n        // update\n        if (k in subscope[_signals]) subscope[k] = v\n        // create\n        else (subscope[_signals][k] = (k[0] == '_' || v?.peek) ? v : signal(store(v)))\n      }\n    }\n\n    // Object.assign(subscope, call(values, subscope))\n    return !init && (init = true, delete el[_state], untracked(() => sprae(el, subscope)))\n  }\n}\n", "import sprae, { store, _state, effect, _change, _signals, frag, throttle } from \"../core.js\";\n\nconst each = (tpl, state, expr) => {\n  let [itemVar, idxVar = \"$\"] = expr.split(/\\bin\\b/)[0].trim().replace(/\\(|\\)/g, '').split(/\\s*,\\s*/);\n\n  // we need :if to be able to replace holder instead of tpl for :if :each case\n  let holder = document.createTextNode(\"\");\n\n  // we re-create items any time new items are produced\n  let cur, keys, items, prevl = 0\n\n  // FIXME: pass items to update instead of global\n  let update = throttle(() => {\n    let i = 0, newItems = items, newl = newItems.length\n\n    // plain array update, not store (signal with array) - updates full list\n    if (cur && !cur[_change]) {\n      for (let s of cur[_signals] || []) s[Symbol.dispose]()\n      cur = null, prevl = 0\n    }\n\n    // delete\n    if (newl < prevl) cur.length = newl\n\n    // update, append, init\n    else {\n      // init\n      if (!cur) cur = newItems\n      // update\n      else while (i < prevl) cur[i] = newItems[i++]\n\n      // append\n      for (; i < newl; i++) {\n        cur[i] = newItems[i]\n\n        let idx = i,\n          // inherited state must be cheaper in terms of memory and faster in terms of performance, compared to creating a proxy store\n          // subscope = store({\n          //   // NOTE: since we simulate signal, we have to make sure it's actual signal, not fake one\n          //   // FIXME: try to avoid this, we also have issue with wrongly calling dispose in store on delete\n          //   [itemVar]: cur[_signals]?.[idx]?.peek ? cur[_signals]?.[idx] : cur[idx],\n          //   [idxVar]: keys ? keys[idx] : idx\n          // }, state)\n        subscope = Object.create(state, {\n          [itemVar]: { get: () => cur[idx] },\n          [idxVar]: { value: keys ? keys[idx] : idx }\n        })\n\n        let el = tpl.content ? frag(tpl) : tpl.cloneNode(true);\n\n        holder.before(el.content || el);\n\n        sprae(el, subscope);\n\n        // signal/holder disposal removes element\n        let _prev = ((cur[_signals] ||= [])[i] ||= {})[Symbol.dispose]\n        cur[_signals][i][Symbol.dispose] = () => {\n          _prev?.(), el[Symbol.dispose]?.(), el.remove()\n        };\n      }\n    }\n\n    prevl = newl\n  })\n\n  tpl.replaceWith(holder);\n  tpl[_state] = null // mark as fake-spraed, to preserve :-attribs for template\n\n  return value => {\n    // resolve new items\n    keys = null\n    if (typeof value === \"number\") items = Array.from({ length: value }, (_, i) => i + 1)\n    else if (value?.constructor === Object) keys = Object.keys(value), items = Object.values(value)\n    else items = value || []\n\n    // whenever list changes, we rebind internal change effect\n    return effect(() => {\n      // subscribe to items change (.length) - we do it every time (not just in update) since preact unsubscribes unused signals\n      items[_change]?.value\n\n      // make first render immediately, debounce subsequent renders\n      update()\n    })\n  }\n}\n\n// :each directive skips v, k\neach.parse = (str) => str.split(/\\bin\\b/)[1].trim()\n\nexport default each\n", "import { attr, call } from \"../core.js\";\n\nexport default (el, st, ex, name) => v => attr(el, name, call(v, el.getAttribute(name)))\n", "import { attr, dashcase } from \"../core.js\";\n\nexport default (target) => value => { for (let key in value) attr(target, dashcase(key), value[key]) }\n", "import store from \"./store.js\";\nimport { batch, computed, effect, signal, untracked } from './signal.js';\nimport sprae, { use, directive, modifier, start, throttle, debounce, _add, _off, _state, _on, _dispose } from './core.js';\n\nimport _if from \"./directive/if.js\";\nimport _else from \"./directive/else.js\";\nimport _text from \"./directive/text.js\";\nimport _class from \"./directive/class.js\";\nimport _style from \"./directive/style.js\";\nimport _fx from \"./directive/fx.js\";\nimport _value from \"./directive/value.js\";\nimport _ref from \"./directive/ref.js\";\nimport _scope from \"./directive/scope.js\";\nimport _each from \"./directive/each.js\";\nimport _default from \"./directive/default.js\";\nimport _spread from \"./directive/spread.js\";\n\n\nObject.assign(directive, {\n  // :x=\"x\"\n  '*': _default,\n\n  // FIXME\n  // 'on*': _on,\n\n  // :=\"{a,b,c}\"\n  '': _spread,\n\n  // :class=\"[a, b, c]\"\n  class: _class,\n\n  // :text=\"...\"\n  text: _text,\n\n  // :style=\"...\"\n  style: _style,\n\n  // :fx=\"...\"\n  fx: _fx,\n\n  // :value - 2 way binding like x-model\n  value: _value,\n\n  // :ref=\"...\"\n  ref: _ref,\n\n  // :scope creates variables scope for a subtree\n  scope: _scope,\n\n  if: _if,\n  else: _else,\n\n  // :each=\"v,k in src\"\n  each: _each\n})\n\nObject.assign(modifier, {\n  debounce: (fn,\n    _how = 250,\n    _schedule = _how === \"tick\" ? queueMicrotask : _how === \"raf\" ? requestAnimationFrame : _how === \"idle\" ? requestIdleCallback : ((fn) => setTimeout(fn, _how)),\n    _count = 0\n  ) =>\n    debounce(fn, _schedule),\n\n  throttle: (fn, _how = 250, _schedule = _how === \"tick\" ? queueMicrotask : _how === \"raf\" ? requestAnimationFrame : ((fn) => setTimeout(fn, _how))) => (\n    throttle(fn, _schedule)\n  ),\n\n  once: (fn, _done, _fn) => Object.assign((e) => !_done && (_done = 1, fn(e)), { once: true }),\n\n  // event modifiers\n  // actions\n  prevent: (fn) => (e) => (e?.preventDefault(), fn(e)),\n  stop: (fn) => (e) => (e?.stopPropagation(), fn(e)),\n  immediate: (fn) => (e) => (e?.stopImmediatePropagation(), fn(e)),\n\n  // options\n  passive: fn => (fn.passive = true, fn),\n  capture: fn => (fn.capture = true, fn),\n\n  // target\n  window: fn => (fn.target = fn.target.ownerDocument.defaultView, fn),\n  document: fn => (fn.target = fn.target.ownerDocument, fn),\n  root: fn => (fn.target = fn.target.ownerDocument.documentElement, fn),\n  body: fn => (fn.target = fn.target.ownerDocument.body, fn),\n  parent: fn => (fn.target = fn.target.parentNode, fn),\n\n  // testers\n  self: (fn) => (e) => (e.target === fn.target && fn(e)),\n\n  outside: (fn) => (e, _target) => (\n    _target = fn.target,\n    !_target.contains(e.target) && e.target.isConnected && (_target.offsetWidth || _target.offsetHeight)\n  ),\n})\n\n// key testers\nconst keys = {\n  ctrl: e => e.ctrlKey || e.key === \"Control\" || e.key === \"Ctrl\",\n  shift: e => e.shiftKey || e.key === \"Shift\",\n  alt: e => e.altKey || e.key === \"Alt\",\n  meta: e => e.metaKey || e.key === \"Meta\" || e.key === \"Command\",\n  arrow: e => e.key.startsWith(\"Arrow\"),\n  enter: e => e.key === \"Enter\",\n  esc: e => e.key.startsWith(\"Esc\"),\n  tab: e => e.key === \"Tab\",\n  space: e => e.key === \"\u00A0\" || e.key === \"Space\" || e.key === \" \",\n  delete: e => e.key === \"Delete\" || e.key === \"Backspace\",\n  digit: e => /^\\d$/.test(e.key),\n  letter: e => /^\\p{L}$/gu.test(e.key),\n  char: e => /^\\S$/.test(e.key),\n};\n\n// augment modifiers with key testers\nfor (let k in keys) modifier[k] = (fn, ...params) => (e) => keys[k](e) && params.every(k => keys[k]?.(e) ?? e.key === k) && fn(e)\n\nuse({\n  compile: expr => {\n    return sprae.constructor(`with (arguments[0]) { ${expr} }`)\n  },\n\n  // signals\n  signal, effect, computed, batch, untracked\n})\n\n// expose for runtime config\nsprae.use = use\nsprae.store = store\nsprae.directive = directive\nsprae.modifier = modifier\nsprae.start = start\n\nexport default sprae\nexport { sprae, store, signal, effect, computed, batch, untracked, start, use }\n", "var sprae = require(\"./sprae.js\").default; module.exports = sprae; var cur = document.currentScript;\nvar prefix = cur.getAttribute(\"prefix\") ?? cur.dataset.prefix ?? cur.dataset.spraePrefix;\nvar start = cur.getAttribute(\"start\") ?? cur.dataset.start ?? cur.dataset.spraeStart;\nif (prefix) sprae.use({ prefix });\nif (start != null && start !== 'false') (start && start !== 'true' ? document.querySelectorAll(start) : [document.body || document.documentElement]).forEach(el => sprae.start(el))"],
  "mappings": "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",
  "names": ["fn", "off", "el", "cur", "e", "attr", "signal", "effect", "computed", "batch", "untracked", "_set", "set", "_set", "cur", "keys", "batch", "computed", "effect", "signal", "untracked", "fn", "k", "sprae", "prefix", "start"]
}
