{
  "version": 3,
  "sources": ["../core.js", "../store.js", "../signal.js", "../directive/if.js", "../directive/else.js", "../directive/text.js", "../directive/class.js", "../directive/style.js", "../directive/fx.js", "../directive/value.js", "../directive/ref.js", "../directive/scope.js", "../directive/each.js", "../directive/default.js", "../directive/spread.js", "../sprae.js", "<stdin>"],
  "sourcesContent": ["import store, { _change, _signals } from \"./store.js\";\n\nexport const _dispose = (Symbol.dispose ||= Symbol(\"dispose\")),\n  _state = Symbol(\"state\"),\n  _on = Symbol('on'),\n  _off = Symbol('off'),\n  _add = Symbol('add');\n\n\nexport let prefix = ':', signal, effect, computed, batch = (fn) => fn(), untracked = batch;\n\nlet directive = {}, modifier = {}\n\n/**\n * Applies directives to an HTML element and manages its reactive state.\n *\n * @param {Element} [el=document.body] - The target HTML element to apply directives to.\n * @param {Object|store} [state] - Initial state values to populate the element's reactive state.\n * @returns {Object} The reactive state object associated with the element.\n */\nconst sprae = (el = document.body, state) => {\n  // repeated call can be caused by eg. :each with new objects with old keys\n  if (el[_state]) return Object.assign(el[_state], state)\n\n  // console.group('sprae', el.outerHTML)\n\n  // take over existing state instead of creating a clone\n  state = store(state || {})\n\n  let fx = [], offs = [], fn,\n    // FIXME: on generally needs to account for events, although we call it only in :if\n    on = () => (!offs && (offs = fx.map(fn => fn()))),\n    off = () => (offs?.map(off => off()), offs = null)\n\n  // on/off all effects\n  // we don't call prevOn as convention: everything defined before :else :if won't be disabled by :if\n  // imagine <x :onx=\"...\" :if=\"...\"/> - when :if is false, it disables directives after :if (calls _off) but ignores :onx\n  el[_on] = on\n  el[_off] = off\n\n  // destroy\n  el[_dispose] ||= () => (el[_off](), el[_off] = el[_on] = el[_dispose] = el[_state] = el[_add] = null)\n\n  const add = (el, _attrs = el.attributes) => {\n    // we iterate live collection (subsprae can init args)\n    if (_attrs) for (let i = 0; i < _attrs.length;) {\n      let { name, value } = _attrs[i]\n\n      if (name.startsWith(prefix)) {\n        el.removeAttribute(name)\n\n        // directive initializer can be redefined\n        fx.push(fn = initDirective(el, name, value, state))\n        offs.push(fn())\n\n        // stop after subsprae like :each, :if, :scope etc.\n        if (_state in el) return\n      } else i++\n    }\n\n    // :if and :each replace element with text node, which tweaks .children length, but .childNodes length persists\n    // for (let i = 0, child; i < (el.childNodes.length); i++) child =  el.childNodes[i], child.nodeType == 1 && add(child)\n    // FIXME: don't do spread here\n    for (let child of [...el.childNodes]) child.nodeType == 1 && add(child)\n  };\n\n  el[_add] = add;\n\n  add(el);\n\n  // if element was spraed by inline :with/:if/:each/etc instruction (meaning it has state placeholder) - skip, otherwise save _state\n  if (el[_state] === undefined) el[_state] = state\n\n  // console.groupEnd()\n\n  return state;\n}\n\n\n/**\n * Initializes directive (defined by sprae build), returns \"on\" function that enables it\n * Multiprop sequences initializer, eg. :a:b..c:d\n * @type {(el: HTMLElement, name:string, value:string, state:Object) => Function}\n * */\nconst initDirective = (el, attrName, expr, state) => {\n  let cur, // current step callback\n    off // current step disposal\n\n  // FIXME: separate cases: async, event, sequence, single attr\n\n  let steps = attrName.slice(prefix.length).split('..').map((step, i, { length }) => (\n    // multiple attributes like :id:for=\"\"\n    step.split(prefix).reduce((prev, str) => {\n      let [name, ...mods] = str.split('.'),\n        // event is either :click or :onclick, since on* events never intersect with * attribs\n        isEvent = (name.startsWith('on') && (name = name.slice(2), true)) || el['on' + name],\n        evaluate = parse(name, expr, directive[name]?.clean)\n\n      // events have no effects and can be sequenced\n      if (isEvent) {\n        let first = e => (call(evaluate(state), e)),\n          fn = applyMods(\n            Object.assign(\n              // single event vs chain\n              length == 1 ? first :\n                e => (cur = (!i ? first : cur)(e), off(), off = steps[(i + 1) % length]()),\n              { target: el, type: name }\n            ),\n            mods);\n\n        return (_poff) => (_poff = prev?.(), fn.target.addEventListener(name, fn, fn), () => (_poff?.(), fn.target.removeEventListener(name, fn)))\n      }\n\n      // props have no sequences and can be sync\n      let update = (directive[name] || directive['*'])(el, state, expr, name)\n\n      // no-modifiers shortcut\n      if (!mods.length && !prev) return () => update && effect(() => (update(evaluate(state))))\n\n      let dispose,\n        change = signal(-1), // signal authorized to trigger effect: 0 = init; >0 = trigger\n        count = -1, // called effect count\n\n        // effect applier - first time it applies the effect, next times effect is triggered by change signal\n        // FIXME: init via dispose, don't reset count\n        fn = throttle(applyMods(() => {\n          if (++change.value) return // all calls except for the first one are handled by effect\n          dispose = effect(() => update && (\n            change.value == count ? fn() : // separate tick makes sure planner effect call is finished before real eval call\n              (count = change.value, update(evaluate(state))) // if changed more than effect called - call it\n          ));\n        }, mods))\n\n      return (_poff) => (\n        _poff = prev?.(),\n        // console.log('ON', name),\n        fn(),\n        ({\n          [name]: () => (\n            // console.log('OFF', name, el),\n            _poff?.(), dispose(), change.value = -1, count = dispose = null\n          )\n        })[name]\n      )\n    }, null)\n  ));\n\n  // off can be changed on the go\n  return () => (off = steps[0]())\n}\n\n\n/**\n * Configure sprae\n */\nexport const use = (s) => (\n  s.directive && (directive = s.directive),\n  s.modifier && (modifier = s.modifier),\n  s.compile && (compile = s.compile),\n  s.prefix && (prefix = s.prefix),\n  s.signal && (signal = s.signal),\n  s.effect && (effect = s.effect),\n  s.computed && (computed = s.computed),\n  s.batch && (batch = s.batch),\n  s.untracked && (untracked = s.untracked)\n)\n\n\n/**\n * Lifecycle hanger: makes DOM slightly slower but spraes automatically\n */\nexport const start = (root = document.body, values) => {\n  const state = store(values);\n  sprae(root, state);\n  const mo = new MutationObserver(mutations => {\n    for (const m of mutations) {\n      for (const el of m.addedNodes) {\n        if (el.nodeType === 1 && el[_state] === undefined) {\n          for (const attr of el.attributes) {\n            if (attr.name.startsWith(prefix)) {\n              root[_add](el); break;\n            }\n          }\n        }\n      }\n      // for (const el of m.removedNodes) el[Symbol.dispose]?.()\n    }\n  });\n  mo.observe(root, { childList: true, subtree: true });\n  return state\n}\n\n\n/**\n * Compiles an expression into an evaluator function.\n * @type {(dir:string, expr: string, clean?: string => string) => Function}\n */\nexport let compile\n\n/**\n * Parses an expression into an evaluator function, caching the result for reuse.\n *\n * @param {string} expr The expression to parse and compile into a function.\n * @returns {Function} The compiled evaluator function for the expression.\n */\nconst parse = (dir, expr, _clean = trim, _fn) => {\n  // expr.split(/\\bin\\b/)[1]\n  if (_fn = cache[expr = _clean(expr)]) return _fn\n\n  // static time errors\n  try { _fn = compile(expr) } catch (e) { console.error(`\u2234 ${e}\\n\\n${prefix + dir}=\"${expr}\"`) }\n\n  // run time errors\n  return cache[expr] = (s) => { try { return _fn?.(s) } catch (e) { console.error(`\u2234 ${e}\\n\\n${prefix + dir}=\"${expr}\"`) } }\n}\n\nexport const cache = {};\nexport const trim = e => e.trim()\n\n\n// apply modifiers to context (from the end due to nature of wrapping ctx.call)\nconst applyMods = (fn, mods) => {\n  while (mods.length) {\n    let [name, ...params] = mods.pop().split('-')\n    fn = sx(modifier[name]?.(fn, ...params) ?? fn, fn)\n  }\n  return fn\n}\n\n// soft-extend missing props and ignoring signals\nconst sx = (a, b) => { if (a != b) for (let k in b) (a[k] ??= b[k]); return a }\n\n// create expression setter, reflecting value back to state\nexport const setter = (dir, expr, _set = parse(dir, `${expr}=__`)) => (target, value) => {\n  // save value to stash\n  target.__ = value; _set(target), delete target.__\n}\n\n// instantiated <template> fragment holder, like persisting fragment but with minimal API surface\nexport const frag = (tpl) => {\n  if (!tpl.nodeType) return tpl // existing tpl\n\n  let content = tpl.content.cloneNode(true), // document fragment holder of content\n    attributes = [...tpl.attributes],\n    ref = document.createTextNode(''),\n    // ensure at least one node\n    childNodes = (content.append(ref), [...content.childNodes])\n\n  return {\n    // get parentNode() { return childNodes[0].parentNode },\n    childNodes,\n    content,\n    remove: () => content.append(...childNodes),\n    replaceWith(el) {\n      if (el === ref) return\n      ref.before(el)\n      content.append(...childNodes)\n    },\n    attributes,\n    removeAttribute(name) { attributes.splice(attributes.findIndex(a => a.name === name), 1) },\n    // setAttributeNode() { }\n  }\n}\n\n// if value is function - return result of its call\nexport const call = (v, arg) => typeof v === 'function' ? v(arg) : v\n\n// camel to kebab\nexport const dashcase = (str) => str.replace(/[A-Z\\u00C0-\\u00D6\\u00D8-\\u00DE]/g, (match, i) => (i ? '-' : '') + match.toLowerCase());\n\n// set attr\nexport const attr = (el, name, v) => (v == null || v === false) ? el.removeAttribute(name) : el.setAttribute(name, v === true ? \"\" : v);\n\n// convert any-arg to className string\nexport const clsx = (c, _out = []) => !c ? '' : typeof c === 'string' ? c : (\n  Array.isArray(c) ? c.map(clsx) :\n    Object.entries(c).reduce((s, [k, v]) => !v ? s : [...s, k], [])\n).join(' ')\n\n// throttle function to (once per tick or other custom scheduler)\nexport const throttle = (fn, schedule=queueMicrotask) => {\n  let _planned = 0;\n  const throttled = (e) => {\n    if (!_planned++) fn(e), schedule((_dirty = _planned > 1) => (\n      _planned = 0, _dirty && throttled(e)\n    ));\n  }\n  return throttled;\n}\n\nexport * from './store.js';\n\nexport default sprae\n", "// signals-based proxy\nimport { signal, computed, batch, untracked } from './core.js'\n\nconst mut = ['push', 'pop', 'shift', 'unshift', 'splice']\n\n// _signals allows both storing signals and checking instance, which would be difficult with WeakMap\nexport const _signals = Symbol('signals'),\n  _change = Symbol('change'),\n  _set = Symbol('set'),\n\n  // object store is not lazy\n  // parent defines parent scope or sandbox\n  store = (values, parent = globalThis) => {\n    if (!values) return values\n\n    // ignore existing state as argument or globals\n    // FIXME: toStringTag is not needed since we read global as parent\n    if (values[Symbol.toStringTag]) return values;\n\n    // bypass existing store\n    if (values[_signals]) return values\n\n    // non-objects: for array redirect to list\n    if (values.constructor !== Object) return Array.isArray(values) ? list(values) : values\n\n    // _change stores total number of keys to track new props\n    // NOTE: be careful\n    let len = Object.keys(values).length, signals = {}\n\n    // proxy conducts prop access to signals\n    let state = new Proxy(meta(signals, len), {\n      get: (_, k) => (k in signals ? (signals[k] ? signals[k].valueOf() : signals[k]) : parent[k]),\n      set: (_, k, v, _s) => (k in signals ? set(signals, k, v) : (create(signals, k, v), signals[_change].value = ++len), 1), // bump length for new signal\n      // FIXME: try to avild calling Symbol.dispose here\n      deleteProperty: (_, k) => (k in signals && (k[0] != '_' && signals[k]?.[Symbol.dispose]?.(), delete signals[k], signals[_change].value = --len), 1),\n      // subscribe to length when object is spread\n      ownKeys: () => (signals[_change].value, Reflect.ownKeys(signals)),\n      has: _ => 1 // sandbox prevents writing to global\n    }),\n\n      // init signals for values\n      descs = Object.getOwnPropertyDescriptors(values)\n\n    for (let k in values) {\n      // getter turns into computed\n      if (descs[k]?.get)\n        // stash setter\n        (signals[k] = computed(descs[k].get.bind(state)))[_set] = descs[k].set?.bind(state);\n\n      // init blank signal - make sure we don't take prototype one\n      else create(signals, k, values[k])\n    }\n\n    return state\n  },\n\n  // array store - signals are lazy since arrays can be very large & expensive\n  list = (values, parent = globalThis) => {\n\n    // track last accessed property to find out if .length was directly accessed from expression or via .push/etc method\n    let lastProp,\n\n      // gotta fill with null since proto methods like .reduce may fail\n      signals = Array(values.length).fill(null),\n\n      // proxy conducts prop access to signals\n      state = new Proxy(\n        meta(signals, signals.length),\n        {\n          get(_, k) {\n            // if .length is read within mutators - peek signal to avoid recursive subscription\n            if (k === 'length') return mut.includes(lastProp) ? signals.length : signals[_change].value;\n\n            lastProp = k;\n\n            // create signal (lazy)\n            // NOTE: if you decide to unlazy values, think about large arrays - init upfront can be costly\n            return signals[k] ? signals[k].valueOf() : k in signals ? (signals[k] = signal(store(values[k]))).valueOf() : parent[k]\n          },\n\n          set(_, k, v) {\n            // .length\n            if (k === 'length') {\n              // force cleaning up tail\n              for (let i = v; i < signals.length; i++) delete state[i]\n              // .length = N directly\n              signals[_change].value = signals.length = v;\n            }\n\n            // force changing length, if eg. a=[]; a[1]=1 - need to come after setting the item\n            else if (k >= signals.length) create(signals, k, v), state.length = +k + 1\n\n            // existing signal\n            else signals[k] ? set(signals, k, v) : create(signals, k, v)\n\n            return 1\n          },\n\n          // dispose notifies any signal deps, like :each\n          deleteProperty: (_, k) => (signals[k]?.[Symbol.dispose]?.(), delete signals[k], 1),\n        })\n\n    return state\n  },\n\n  // create signal value, skip untracked\n  create = (signals, k, v) => (signals[k] = k[0] == '_' || v?.peek ? v : signal(store(v))),\n\n  // set/update signal value\n  set = (signals, k, v, _s, _v) => {\n    // skip unchanged (although can be handled by last condition - we skip a few checks this way)\n    return k[0] === '_' ? (signals[k] = v) :\n      (v !== (_v = (_s = signals[k]).peek())) && (\n        // stashed _set for value with getter/setter\n        _s[_set] ? _s[_set](v) :\n          // patch array\n          Array.isArray(v) && Array.isArray(_v) ?\n            // if we update plain array (stored in signal) - take over value instead\n            // since input value can be store, we have to make sure we don't subscribe to its length or values\n            // FIXME: generalize to objects\n            _change in _v ? untracked(() => batch(() => {\n              for (let i = 0; i < v.length; i++) _v[i] = v[i]\n              _v.length = v.length // forces deleting tail signals\n            })) : _s.value = v :\n            // .x = y\n            (_s.value = store(v))\n      )\n  },\n\n  // create state meta props\n  meta = (signals, len) => (\n    Object.assign(signals, { [_change]: signal(len), [_signals]: signals })\n    // Object.defineProperties(signals, {\n    //   [_change]: { value: signal(len), enumerable: false },\n    //   [_signals]: { value: signals, enumerable: false }\n    // }),\n    // signals\n  )\n\n\n// make sure state contains first element of path, eg. `a` from `a.b[c]`\n// NOTE: we don't need since we force proxy sandbox\n// export const ensure = (state, expr, name = expr.match(/^\\w+(?=\\s*(?:\\.|\\[|$))/)) => name && (state[_signals][name[0]] ??= null)\n\nexport default store\n", "// preact-signals minimal implementation\nlet current, depth = 0, batched;\n\n// default signals impl\n\nexport const signal = (v, _s, _obs = new Set, _v = () => _s.value) => (\n  _s = {\n    get value() {\n      current?.deps.push(_obs.add(current));\n      return v\n    },\n    set value(val) {\n      if (val === v) return\n      v = val;\n      for (let sub of _obs) batched ? batched.add(sub) : sub(); // notify effects\n    },\n    peek() { return v },\n    toJSON: _v, then: _v, toString: _v, valueOf: _v\n  }\n)\n\nexport const effect = (fn, _teardown, _fx, _deps, __tmp) => (\n  _fx = (prev) => {\n    __tmp = _teardown;\n    _teardown = null; // we null _teardown to avoid repeated call in case of recursive update\n    __tmp?.call?.();\n    prev = current, current = _fx\n    if (depth++ > 10) throw 'Cycle detected';\n    try { _teardown = fn(); } finally { current = prev; depth-- }\n  },\n  _deps = _fx.deps = [],\n\n  _fx(),\n  (dep) => { _teardown?.call?.(); while (dep = _deps.pop()) dep.delete(_fx); }\n)\n\nexport const computed = (fn, _s = signal(), _c, _e, _v = () => _c.value) => (\n  _c = {\n    get value() {\n      _e ||= effect(() => _s.value = fn());\n      return _s.value\n    },\n    peek: _s.peek,\n    toJSON: _v, then: _v, toString: _v, valueOf: _v\n  }\n)\n\nexport const batch = (fn, _first = !batched) => {\n  batched ??= new Set;\n  try { fn(); }\n  finally { if (_first) { for (const fx of batched) fx(); batched = null } }\n}\n\nexport const untracked = (fn, _prev, _v) => (_prev = current, current = null, _v = fn(), current = _prev, _v)\n", "// \"centralized\" version of :if\nimport sprae, { throttle, _on, _off, _state, frag } from '../core.js';\n\n// :if=\"a\"\nexport default (el, state, _holder, _el, _match) => {\n  // new element :if\n  // console.log(':if init', el)\n  if (!el._holder) {\n    // mark el as fake-spraed to delay init, since we sprae rest when branch matches, both :if and :else :if\n    el[_state] ??= null\n\n    _el = el.content ? frag(el) : el\n\n    el.replaceWith(_holder = document.createTextNode(''))\n    _el._holder = _holder._holder = _holder\n\n\n    _holder._clauses = [_el._clause = [_el, false]]\n\n    _holder.update = throttle(() => {\n      let match = _holder._clauses.find(([, s]) => s)\n      // console.group(':if update clauses', ..._holder._clauses)\n\n      if (match != _match) {\n        // console.log(':if match', match)\n        _match?.[0].remove()\n        // FIXME: we don't turn off\n        _match?.[0][_off]?.()\n        if (_match = match) {\n          _holder.before(_match[0].content || _match[0])\n          // there's no :else after :if, so lazy-sprae here doesn't risk adding own destructor to own list of destructors\n          !_match[0][_state] ? (delete _match[0][_state], sprae(_match[0], state)) : _match[0][_on]?.()\n        }\n      }\n      // console.groupEnd()\n    })\n  }\n  // :else :if needs to be spraed all over to have clean list of offable effects\n  else sprae(_el = el, state)\n\n  // :else may have children to init which is called after :if\n  // or preact can schedule :else after :if, so we ensure order of call by next tick\n  return value => {\n    // console.log(':if update', _el, value)\n    _el._clause[1] = value\n    _el._holder.update()\n  }\n}\n", "import { _on, _off, _state, frag } from '../core.js';\n\n\n// NOTE: we can reach :else counterpart whereas prev :else :if is on hold\nexport default (el, state, _el) => (\n\n  _el = el.content ? frag(el) : el,\n\n  _el._holder = el.previousSibling?._holder || el.previousSibling?.previousSibling?._holder,\n  el.remove(),\n  el[_state] = null, // mark as fake-spraed to stop further init, to lazy-sprae when branch matches\n\n  _el._holder._clauses.push(_el._clause = [_el, true]),\n\n  () => {\n    _el._holder.update()\n  }\n)\n", "import { frag, call } from \"../core.js\"\n\nexport default el => (\n  // <template :text=\"a\"/> or previously initialized template\n  // FIXME: replace with content maybe?\n  el.content && el.replaceWith(el = frag(el).childNodes[0]),\n  v => (v = call(v, el.textContent), el.textContent = v == null ? \"\" : v)\n)\n", "import { clsx, call } from \"../core.js\";\n\nexport default (el, _cur, _new) => (\n  _cur = new Set,\n  (v) => {\n    _new = new Set\n    if (v) clsx(call(v, el.className)).split(' ').map(c => c && _new.add(c))\n    for (let c of _cur) if (_new.has(c)) _new.delete(c); else el.classList.remove(c);\n    for (let c of _cur = _new) el.classList.add(c)\n  }\n)\n", "import { call, attr } from \"../core.js\";\n\nexport default (el, _static) => (\n  _static = el.getAttribute(\"style\"),\n  v => {\n    v = call(v, el.style)\n    if (typeof v === \"string\") attr(el, \"style\", _static + '; ' + v);\n    else {\n      if (_static) attr(el, \"style\", _static);\n      // NOTE: we skip names not starting with a letter - eg. el.style stores properties as { 0: --x } or JSDOM has _pfx\n      for (let k in v) k[0] == '-' ? el.style.setProperty(k, v[k]) : k[0] > 'A' && (el.style[k] = v[k])\n    }\n  }\n)\n", "import { call } from \"../core.js\"\n\nexport default () => v => (call(v))\n", "import sprae,{ setter, attr, cache, trim, _state } from \"../core.js\";\n\nexport default (el, state, expr, name) => {\n  // bind back to value, but some values can be not bindable, eg. `:value=\"7\"`\n  try {\n    const set = setter(name, expr)\n    const handleChange = el.type === 'checkbox' ? () => set(state, el.checked) :\n      el.type === 'select-multiple' ? () => set(state, [...el.selectedOptions].map(o => o.value)) :\n        () => set(state, el.selectedIndex < 0 ? null : el.value)\n\n    el.oninput = el.onchange = handleChange; // hope user doesn't redefine these manually via `.oninput = somethingElse` - it saves 5 loc vs addEventListener\n\n    if (el.type?.startsWith('select')) {\n      // select element also must observe any added/removed options or changed values (outside of sprae)\n      new MutationObserver(handleChange).observe(el, { childList: true, subtree: true, attributes: true });\n\n      // select options must be initialized before calling an update\n      sprae(el, state)\n    }\n\n    // initial state value - setter has already cached it, no need to parse again\n    cache[trim(expr)](state) ?? handleChange()\n  } catch { }\n\n  return (el.type === \"text\" || el.type === \"\") ?\n    (value) => el.setAttribute(\"value\", (el.value = value == null ? \"\" : value)) :\n    (el.tagName === \"TEXTAREA\" || el.type === \"text\" || el.type === \"\") ?\n      (value, from, to) => (\n        // we retain selection in input\n        (from = el.selectionStart),\n        (to = el.selectionEnd),\n        el.setAttribute(\"value\", (el.value = value == null ? \"\" : value)),\n        from && el.setSelectionRange(from, to)\n      ) :\n      (el.type === \"checkbox\") ?\n        (value) => (el.checked = value, attr(el, \"checked\", value)) :\n        (el.type === 'radio') ? (value) => (\n          el.value === value && ((el.checked = value), attr(el, 'checked', value))\n        ) :\n          (el.type === \"select-one\") ?\n            (value) => {\n              for (let o of el.options)\n                o.value == value ? o.setAttribute(\"selected\", '') : o.removeAttribute(\"selected\");\n              el.value = value;\n            } :\n            (el.type === 'select-multiple') ? (value) => {\n              for (let o of el.options) o.removeAttribute('selected')\n              for (let v of value) el.querySelector(`[value=\"${v}\"]`).setAttribute('selected', '')\n            } :\n              (value) => (el.value = value);\n}\n", "import { setter, cache, trim } from \"../core.js\"\n\nexport default (el, state, expr, name, _prev, _set) => (\n  typeof cache[trim(expr)](state) == 'function' ?\n    v => (v(el)) :\n    // NOTE: we have to set element statically (outside of effect) to avoid parasitic sub - multiple els with same :ref can cause recursion (eg. :each :ref=\"x\")\n    (setter(name, expr)(state, el))\n)\n", "import sprae, { store, call, untracked, _state } from '../core.js'\n\nexport default (el, rootState, _scope) => (\n  // prevent subsequent effects\n  el[_state] = null,\n  // 0 run pre-creates state to provide scope for the first effect - it can write vars in it, so we should already have it\n  _scope = store({}, rootState),\n  // 1st run spraes subtree with values from scope - it can be postponed by modifiers (we isolate reads from parent effect)\n  // 2nd+ runs update _scope\n  values => (Object.assign(_scope, call(values, _scope)), el[_state] ?? (delete el[_state], untracked(() => sprae(el, _scope))))\n)\n", "import sprae, { store, _state, effect, _change, _signals, frag, throttle } from \"../core.js\";\n\nconst each = (tpl, state, expr) => {\n  let [itemVar, idxVar = \"$\"] = expr.split(/\\bin\\b/)[0].trim().replace(/\\(|\\)/g, '').split(/\\s*,\\s*/);\n\n  // we need :if to be able to replace holder instead of tpl for :if :each case\n  let holder = document.createTextNode(\"\");\n\n  // we re-create items any time new items are produced\n  let cur, keys, items, prevl = 0\n\n  // FIXME: pass items to update instead of global\n  let update = throttle(() => {\n    let i = 0, newItems = items, newl = newItems.length\n\n    // plain array update, not store (signal with array) - updates full list\n    if (cur && !cur[_change]) {\n      for (let s of cur[_signals] || []) s[Symbol.dispose]()\n      cur = null, prevl = 0\n    }\n\n    // delete\n    if (newl < prevl) cur.length = newl\n\n    // update, append, init\n    else {\n      // init\n      if (!cur) cur = newItems\n      // update\n      else while (i < prevl) cur[i] = newItems[i++]\n\n      // append\n      for (; i < newl; i++) {\n        cur[i] = newItems[i]\n\n        let idx = i,\n          // FIXME: inherited state is cheaper in terms of memory and faster in terms of performance, compared to creating a proxy\n          subscope = store({\n            // NOTE: since we simulate signal, we have to make sure it's actual signal, not fake one\n            // FIXME: try to avoid this, we also have issue with wrongly calling dispose in store on delete\n            [itemVar]: cur[_signals]?.[idx]?.peek ? cur[_signals]?.[idx] : cur[idx],\n            [idxVar]: keys ? keys[idx] : idx\n          }, state)\n        // subscope = Object.create(state, {\n        //   [itemVar]: { get: () => cur[idx] },\n        //   [idxVar]: { value: keys ? keys[idx] : idx }\n        // })\n\n        let el = tpl.content ? frag(tpl) : tpl.cloneNode(true);\n\n        holder.before(el.content || el);\n\n        sprae(el, subscope);\n\n        // signal/holder disposal removes element\n        let _prev = ((cur[_signals] ||= [])[i] ||= {})[Symbol.dispose]\n        cur[_signals][i][Symbol.dispose] = () => {\n          _prev?.(), el[Symbol.dispose]?.(), el.remove()\n        };\n      }\n    }\n\n    prevl = newl\n  })\n\n  tpl.replaceWith(holder);\n  tpl[_state] = null // mark as fake-spraed, to preserve :-attribs for template\n\n  return value => {\n    // resolve new items\n    keys = null\n    if (typeof value === \"number\") items = Array.from({ length: value }, (_, i) => i + 1)\n    else if (value?.constructor === Object) keys = Object.keys(value), items = Object.values(value)\n    else items = value || []\n\n    // whenever list changes, we rebind internal change effect\n    return effect(() => {\n      // subscribe to items change (.length) - we do it every time (not just in update) since preact unsubscribes unused signals\n      items[_change]?.value\n\n      // make first render immediately, debounce subsequent renders\n      update()\n    })\n  }\n}\n\n// :each directive skips v, k\neach.clean = (str) => str.split(/\\bin\\b/)[1].trim()\n\nexport default each\n", "import { attr, call } from \"../core.js\";\n\nexport default (el, st, ex, name) => v => attr(el, name, call(v, el.getAttribute(name)))\n", "import { attr, dashcase } from \"../core.js\";\n\nexport default (target) => value => { for (let key in value) attr(target, dashcase(key), value[key]) }\n", "import store, { _change, _signals } from \"./store.js\";\nimport { batch, computed, effect, signal, untracked } from './signal.js';\nimport sprae, { use, start, _off, _state, _on, _dispose, throttle, _add } from './core.js';\n\nimport _if from \"./directive/if.js\";\nimport _else from \"./directive/else.js\";\nimport _text from \"./directive/text.js\";\nimport _class from \"./directive/class.js\";\nimport _style from \"./directive/style.js\";\nimport _fx from \"./directive/fx.js\";\nimport _value from \"./directive/value.js\";\nimport _ref from \"./directive/ref.js\";\nimport _scope from \"./directive/scope.js\";\nimport _each from \"./directive/each.js\";\nimport _default from \"./directive/default.js\";\nimport _spread from \"./directive/spread.js\";\n\n\nconst directive =  {\n  // :x=\"x\"\n  '*': _default,\n\n  // :=\"{a,b,c}\"\n  '': _spread,\n\n  // :class=\"[a, b, c]\"\n  class: _class,\n\n  // :text=\"...\"\n  text: _text,\n\n  // :style=\"...\"\n  style: _style,\n\n  // :fx=\"...\"\n  fx: _fx,\n\n  // :value - 2 way binding like x-model\n  value: _value,\n\n  // :ref=\"...\"\n  ref: _ref,\n\n  // :scope creates variables scope for a subtree\n  scope: _scope,\n\n  if: _if,\n  else: _else,\n\n  // :each=\"v,k in src\"\n  each: _each\n}\n\nconst modifier = {\n  // FIXME: add -s, -m, -l classes with values\n  debounce: (fn,\n    _how = 250,\n    _schedule = _how === \"tick\" ? queueMicrotask : _how === \"raf\" ? requestAnimationFrame : _how === \"idle\" ? requestIdleCallback : ((fn) => setTimeout(fn, _how)),\n    _count = 0\n  ) =>\n    (e, _planned=++_count) => (_schedule(() => (_planned == _count && fn(e)))),\n\n  throttle: (fn, _how = 250, _schedule = _how === \"tick\" ? queueMicrotask : _how === \"raf\" ? requestAnimationFrame : ((fn) => setTimeout(fn, _how))) => (\n    throttle(fn, _schedule)\n  ),\n\n  once: (fn, _done, _fn) => Object.assign((e) => !_done && (_done = 1, fn(e)), { once: true }),\n\n  // event modifiers\n  // actions\n  prevent: (fn) => (e) => (e?.preventDefault(), fn(e)),\n  stop: (fn) => (e) => (e?.stopPropagation(), fn(e)),\n  immediate: (fn) => (e) => (e?.stopImmediatePropagation(), fn(e)),\n\n  // options\n  passive: fn => (fn.passive = true, fn),\n  capture: fn => (fn.capture = true, fn),\n\n  // target\n  window: fn => (fn.target = window, fn),\n  document: fn => (fn.target = document, fn),\n  parent: fn => (fn.target = fn.target.parentNode, fn),\n\n  // test\n  self: (fn) => (e) => (e.target === fn.target && fn(e)),\n  // FIXME\n  outside: (fn) => (e, _target) => (\n    _target = fn.target,\n    !_target.contains(e.target) && e.target.isConnected && (_target.offsetWidth || _target.offsetHeight)\n  ),\n\n  // FIXME:\n  //screen: fn => ()\n}\n\n// key testers\nconst keys = {\n  ctrl: e => e.ctrlKey || e.key === \"Control\" || e.key === \"Ctrl\",\n  shift: e => e.shiftKey || e.key === \"Shift\",\n  alt: e => e.altKey || e.key === \"Alt\",\n  meta: e => e.metaKey || e.key === \"Meta\" || e.key === \"Command\",\n  arrow: e => e.key.startsWith(\"Arrow\"),\n  enter: e => e.key === \"Enter\",\n  esc: e => e.key.startsWith(\"Esc\"),\n  tab: e => e.key === \"Tab\",\n  space: e => e.key === \"\u00A0\" || e.key === \"Space\" || e.key === \" \",\n  delete: e => e.key === \"Delete\" || e.key === \"Backspace\",\n  digit: e => /^\\d$/.test(e.key),\n  letter: e => /^\\p{L}$/gu.test(e.key),\n  char: e => /^\\S$/.test(e.key),\n};\n\n// augment modifiers with key testers\nfor (let k in keys) modifier[k] = (fn, ...params) => (e) => keys[k](e) && params.every(k => keys[k]?.(e) ?? e.key === k) && fn(e)\n\n\nuse({\n  directive,\n  modifier,\n\n  // indirect new Function to avoid detector\n  compile: expr => sprae.constructor(`with (arguments[0]) { return ${expr} };`),\n\n  // signals\n  signal, effect, computed, batch, untracked\n})\n\nexport default sprae\nexport { sprae, store, signal, effect, computed, batch, untracked, use, start }\n", "\nvar {default:sprae, use, start} = require(\"./sprae.js\");\nmodule.exports = sprae;\nuse({ prefix: document.currentScript.getAttribute(\"prefix\") || document.currentScript.dataset.spraePrefix || ':' })\nstart();"],
  "mappings": "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",
  "names": ["_dispose", "_state", "_on", "_off", "_add", "prefix", "signal", "effect", "computed", "batch", "untracked", "directive", "modifier", "sprae", "initDirective", "use", "start", "compile", "parse", "cache", "trim", "applyMods", "sx", "setter", "frag", "call", "dashcase", "attr", "clsx", "throttle", "core_default", "init_core", "__esmMin", "init_store", "fn", "el", "state", "store_default", "fx", "offs", "on", "off", "add", "_attrs", "i", "name", "value", "child", "attrName", "expr", "cur", "steps", "step", "length", "prev", "str", "mods", "isEvent", "evaluate", "first", "e", "_poff", "update", "dispose", "change", "count", "s", "root", "values", "mutations", "m", "dir", "_clean", "_fn", "params", "a", "b", "k", "_set", "target", "tpl", "content", "attributes", "ref", "childNodes", "v", "arg", "match", "c", "_out", "schedule", "_planned", "throttled", "_dirty", "mut", "_signals", "_change", "_set", "store", "list", "create", "set", "meta", "store_default", "init_store", "__esmMin", "init_core", "values", "parent", "len", "signals", "state", "_", "k", "v", "_s", "descs", "computed", "lastProp", "signal", "i", "_v", "untracked", "batch", "current", "depth", "batched", "signal", "effect", "computed", "batch", "untracked", "init_signal", "__esmMin", "v", "_s", "_obs", "_v", "val", "sub", "fn", "_teardown", "_fx", "_deps", "__tmp", "prev", "dep", "_c", "_e", "_first", "fx", "_prev", "if_default", "init_if", "__esmMin", "init_core", "el", "state", "_holder", "_el", "_match", "_a", "core_default", "_state", "frag", "throttle", "match", "s", "_off", "_on", "value", "else_default", "init_else", "__esmMin", "init_core", "el", "state", "_el", "frag", "_state", "text_default", "init_text", "__esmMin", "init_core", "el", "frag", "v", "call", "class_default", "init_class", "__esmMin", "init_core", "el", "_cur", "_new", "v", "clsx", "call", "c", "style_default", "init_style", "__esmMin", "init_core", "el", "_static", "v", "call", "attr", "k", "fx_default", "init_fx", "__esmMin", "init_core", "v", "call", "value_default", "init_value", "__esmMin", "init_core", "el", "state", "expr", "name", "set", "setter", "handleChange", "o", "core_default", "cache", "trim", "value", "from", "to", "attr", "v", "ref_default", "init_ref", "__esmMin", "init_core", "el", "state", "expr", "name", "_prev", "_set", "cache", "trim", "v", "setter", "scope_default", "init_scope", "__esmMin", "init_core", "el", "rootState", "_scope", "_state", "store", "values", "call", "untracked", "core_default", "each", "each_default", "init_each", "__esmMin", "init_core", "tpl", "state", "expr", "itemVar", "idxVar", "holder", "cur", "keys", "items", "prevl", "update", "throttle", "_a", "_b", "i", "newItems", "newl", "_change", "s", "_signals", "idx", "subscope", "store", "el", "frag", "core_default", "_prev", "_state", "value", "_", "effect", "str", "default_default", "init_default", "__esmMin", "init_core", "el", "st", "ex", "name", "v", "attr", "call", "spread_default", "init_spread", "__esmMin", "init_core", "target", "value", "key", "attr", "dashcase", "sprae_exports", "__export", "batch", "computed", "sprae_default", "effect", "signal", "core_default", "start", "store_default", "untracked", "use", "directive", "modifier", "keys", "init_sprae", "__esmMin", "init_store", "init_signal", "init_core", "init_if", "init_else", "init_text", "init_class", "init_style", "init_fx", "init_value", "init_ref", "init_scope", "init_each", "init_default", "init_spread", "default_default", "spread_default", "class_default", "text_default", "style_default", "fx_default", "value_default", "ref_default", "scope_default", "if_default", "else_default", "each_default", "fn", "_how", "_schedule", "_count", "e", "_planned", "throttle", "_done", "_fn", "_target", "k", "params", "expr", "sprae", "use", "start"]
}
