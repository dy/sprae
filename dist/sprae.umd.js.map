{
  "version": 3,
  "sources": ["../signal.js", "../store.js", "../core.js", "../directive/if.js", "../directive/each.js", "../directive/ref.js", "../directive/with.js", "../directive/text.js", "../directive/class.js", "../directive/style.js", "../directive/default.js", "../directive/value.js", "../directive/fx.js", "../directive/aria.js", "../directive/data.js", "../sprae.js", "<stdin>"],
  "sourcesContent": ["// ulive copy, stable minimal implementation\nlet current;\n\nexport let signal = (v, s, obs = new Set) => (\n  s = {\n    get value() {\n      current?.deps.push(obs.add(current));\n      return v\n    },\n    set value(val) {\n      if (val === v) return\n      v = val;\n      for (let sub of obs) sub(); // notify effects\n    },\n    peek() { return v },\n  },\n  s.toJSON = s.then = s.toString = s.valueOf = () => s.value,\n  s\n),\n  effect = (fn, teardown, fx, deps) => (\n    fx = (prev) => {\n      teardown?.call?.();\n      prev = current, current = fx;\n      try { teardown = fn(); } finally { current = prev; }\n    },\n    deps = fx.deps = [],\n\n    fx(),\n    (dep) => { teardown?.call?.(); while (dep = deps.pop()) dep.delete(fx); }\n  ),\n  computed = (fn, s = signal(), c, e) => (\n    c = {\n      get value() {\n        e ||= effect(() => s.value = fn());\n        return s.value\n      },\n      peek: s.peek\n    },\n    c.toJSON = c.then = c.toString = c.valueOf = () => c.value,\n    c\n  ),\n  batch = fn => fn(),\n  untracked = batch,\n  // untracked = (fn, prev, v) => (prev = current, current = null, v = fn(), current = prev, v),\n\n  // signals adapter - allows switching signals implementation and not depend on core\n  use = (s) => (\n    signal = s.signal,\n    effect = s.effect,\n    computed = s.computed,\n    batch = s.batch || batch,\n    untracked = s.untracked || untracked\n  )\n", "// signals-based proxy\nimport { signal, computed, batch } from './signal.js'\nimport { parse } from './core.js';\n\nexport const _signals = Symbol('signals'),\n    _change = Symbol('change'),\n    _stash = '__',\n\n  // object store is not lazy\n  store = (values, parent) => {\n    if (!values) return values\n\n    // ignore existing state as argument or globals\n    if (values[_signals] || values[Symbol.toStringTag]) return values;\n\n    // non-objects: for array redirect to list\n    if (values.constructor !== Object) return Array.isArray(values) ? list(values) : values\n\n    // we must inherit signals to allow dynamic extend of parent state\n    let signals = Object.create(parent?.[_signals] || {}),\n    _len = signal(Object.keys(values).length),\n    stash\n\n      // proxy conducts prop access to signals\n    let state = new Proxy(signals, {\n        get: (_, k) => k === _change ? _len : k === _signals ? signals : k === _stash ? stash : k in signals ? signals[k]?.valueOf() : globalThis[k],\n        set: (_, k, v, s) => k === _stash ? (stash = v, 1) : (s = k in signals, set(signals, k, v), s || ++_len.value), // bump length for new signal\n        deleteProperty: (_, k) => (signals[k] && (signals[k][Symbol.dispose]?.(), delete signals[k], _len.value--), 1),\n        // subscribe to length when object is spread\n        ownKeys: () => (_len.value, Reflect.ownKeys(signals)),\n        has: _ => true // sandbox prevents writing to global\n      }),\n\n      // init signals for values\n      descs = Object.getOwnPropertyDescriptors(values)\n\n    for (let k in values) {\n      // getter turns into computed\n      if (descs[k]?.get)\n        // stash setter\n        (signals[k] = computed(descs[k].get.bind(state)))._set = descs[k].set?.bind(state);\n\n      else\n        // init blank signal - make sure we don't take prototype one\n        signals[k] = null, set(signals, k, values[k]);\n    }\n\n    return state\n  },\n\n  // array store - signals are lazy since arrays can be very large & expensive\n  list = values => {\n    // track last accessed property to find out if .length was directly accessed from expression or via .push/etc method\n    let lastProp,\n\n      // .length signal is stored separately, since it cannot be replaced on array\n      _len = signal(values.length),\n\n      // gotta fill with null since proto methods like .reduce may fail\n      signals = Array(values.length).fill(),\n\n      // proxy conducts prop access to signals\n      state = new Proxy(signals, {\n        get(_, k) {\n          // covers Symbol.isConcatSpreadable etc.\n          if (typeof k === 'symbol') return k === _change ? _len : k === _signals ? signals : signals[k]\n\n          // if .length is read within .push/etc - peek signal to avoid recursive subscription\n          if (k === 'length') return mut.includes(lastProp) ? _len.peek() : _len.value;\n\n          lastProp = k;\n\n          // create signal (lazy)\n          // NOTE: if you decide to unlazy values, think about large arrays - init upfront can be costly\n          return (signals[k] ?? (signals[k] = signal(store(values[k])))).valueOf()\n        },\n\n        set(_, k, v) {\n          // .length\n          if (k === 'length') {\n            // force cleaning up tail\n            for (let i = v; i < signals.length; i++) delete state[i]\n            // .length = N directly\n            _len.value = signals.length = v;\n          }\n          else {\n            set(signals, k, v)\n\n            // force changing length, if eg. a=[]; a[1]=1 - need to come after setting the item\n            if (k >= _len.peek()) _len.value = signals.length = +k + 1\n          }\n\n          return 1\n        },\n\n        deleteProperty: (_, k) => (signals[k]?.[Symbol.dispose]?.(), delete signals[k], 1),\n      })\n\n    return state\n  }\n\n// length changing methods\nconst mut = ['push', 'pop', 'shift', 'unshift', 'splice']\n\n// set/update signal value\nconst set = (signals, k, v) => {\n  let s = signals[k], cur\n\n  // untracked\n  if (k[0] === '_') signals[k] = v\n  // new property. preserve signal value as is\n  else if (!s) signals[k] = s = v?.peek ? v : signal(store(v))\n  // skip unchanged (although can be handled by last condition - we skip a few checks this way)\n  else if (v === (cur = s.peek()));\n  // stashed _set for value with getter/setter\n  else if (s._set) s._set(v)\n  // patch array\n  else if (Array.isArray(v) && Array.isArray(cur)) {\n    // if we update plain array (stored in signal) - take over value instead\n    if (cur[_change]) batch(() => {\n      for (let i = 0; i < v.length; i++) cur[i] = v[i]\n      cur.length = v.length // forces deleting tail signals\n    })\n    else s.value = v\n  }\n  // .x = y\n  else s.value = store(v)\n}\n\n// create expression setter, reflecting value back to state\nexport const setter = (expr, set = parse(`${expr}=${_stash}`)) => (\n  (state, value) => (\n    state[_stash] = value, // save value to stash\n    set(state)\n  )\n)\n\n// make sure state contains first element of path, eg. `a` from `a.b[c]`\n// NOTE: we don't need since we force proxy sandbox\n// export const ensure = (state, expr, name = expr.match(/^\\w+(?=\\s*(?:\\.|\\[|$))/)) => name && (state[_signals][name[0]] ??= null)\n\nexport default store\n", "import { use, effect, untracked } from \"./signal.js\";\nimport { store } from './store.js';\n\n// polyfill\nexport const _dispose = (Symbol.dispose ||= Symbol(\"dispose\"));\n\nexport const _state = Symbol(\"state\"), _on = Symbol('on'), _off = Symbol('off')\n\n// registered directives\nexport const directive = {}\n\n/**\n * Register a directive with a parsed expression and evaluator.\n * @param {string} name - The name of the directive.\n * @param {(el: Element, state: Object, expr: string, name: string) => (value: any) => void} create - A function to create the directive.\n * @param {(expr: string) => (state: Object) => any} [p=parse] - Create evaluator from expression string.\n */\nexport const dir = (name, create, p = parse) => directive[name] = (el, expr, state, name, update, evaluate) => (\n  update = create(el, state, expr, name),\n  evaluate = p(expr, ':'+name),\n  () => update(evaluate(state))\n)\n\n/**\n * Applies directives to an HTML element and manages its reactive state.\n *\n * @param {Element} [el=document.body] - The target HTML element to apply directives to.\n * @param {Object} [values] - Initial values to populate the element's reactive state.\n * @returns {Object} The reactive state object associated with the element.\n */\nexport const sprae = (el=document.body, values) => {\n  // repeated call can be caused by eg. :each with new objects with old keys\n  if (el[_state]) return Object.assign(el[_state], values)\n\n  // take over existing state instead of creating a clone\n  let state = store(values || {}), offs = [], fx = []\n\n  let init = (el, attrs = el.attributes) => {\n      // we iterate live collection (subsprae can init args)\n      if (attrs) for (let i = 0; i < attrs.length;) {\n        let { name, value } = attrs[i], update, dir\n\n        // if we have parts meaning there's attr needs to be spraed\n        if (name.startsWith(prefix)) {\n          el.removeAttribute(name);\n\n          // multiple attributes like :id:for=\"\"\n          for (dir of name.slice(prefix.length).split(':')) {\n            update = (directive[dir] || directive.default)(el, value, state, dir)\n\n            // save & start effect\n            fx.push(update)\n            // FIXME: since effect can have async start, we can just use el[_on]\n            offs.push(effect(update))\n\n            // stop after :each, :if, :with etc.\n            if (el[_state] === null) return\n          }\n        } else i++\n      }\n\n      // :if and :each replace element with text node, which tweaks .children length, but .childNodes length persists\n      for (let child of el.childNodes) child.nodeType == 1 && init(child)\n    };\n\n  init(el);\n\n  // if element was spraed by inline :with instruction (meaning it has extended state) - skip, otherwise save _state\n  if (!(_state in el)) {\n    el[_state] = state\n\n    // on/off all effects\n    el[_off] = () => (offs.map(off => off()), offs = [])\n    el[_on] = () => offs = fx.map(f => effect(f))\n\n    // destroy\n    el[_dispose] = () => (el[_off](), el[_off] = el[_on] = el[_dispose] = el[_state] = null)\n  }\n\n  return state;\n}\n\n// configure signals/compile\n// it's more compact than using sprae.signal = signal etc.\nsprae.use = s => (\n  s.signal && use(s),\n  s.compile && (compile = s.compile),\n  s.prefix && (prefix = s.prefix)\n)\n\n/**\n * Parses an expression into an evaluator function, caching the result for reuse.\n *\n * @param {string} expr - The expression to parse and compile into a function.\n * @param {string} dir - The directive associated with the expression (used for error reporting).\n * @returns {Function} The compiled evaluator function for the expression.\n */\nexport const parse = (expr, dir, fn) => {\n  if (fn = memo[expr = expr.trim()]) return fn\n\n  // static time errors\n  try { fn = compile(expr) }\n  catch (e) { err(e, dir, expr) }\n\n  // run time errors\n  return memo[expr] = s => {\n    try { return fn(s) }\n    catch(e) { err(e, dir, expr) }\n  }\n}\nconst memo = {};\n\n/**\n * Branded sprae error with context about the directive and expression\n *\n * @param {Error} e - The original error object to enhance.\n * @param {string} dir - The directive where the error occurred.\n * @param {string} [expr=''] - The expression associated with the error, if any.\n * @throws {Error} The enhanced error object with a formatted message.\n */\nexport const err = (e, dir = '', expr = '') => {\n  throw Object.assign(e, { message: `\u2234 ${e.message}\\n\\n${dir}${expr ? `=\"${expr}\"\\n\\n` : \"\"}`, expr })\n}\n\n/**\n * Compiles an expression into an evaluator function.\n *\n * @type {(expr: string) => Function}\n */\nexport let compile\n\n/**\n * Attributes prefix, by default ':'\n */\nexport let prefix = ':'\n\n// instantiated <template> fragment holder, like persisting fragment but with minimal API surface\nexport const frag = (tpl) => {\n  if (!tpl.nodeType) return tpl // existing tpl\n\n  let content = tpl.content.cloneNode(true), // document fragment holder of content\n    attributes = [...tpl.attributes],\n    ref = document.createTextNode(''),\n    // ensure at least one node\n    childNodes = (content.append(ref), [...content.childNodes])\n\n  return {\n    // get parentNode() { return childNodes[0].parentNode },\n    childNodes,\n    content,\n    remove: () => content.append(...childNodes),\n    replaceWith(el) {\n      if (el === ref) return\n      ref.before(el)\n      content.append(...childNodes)\n    },\n    attributes,\n    removeAttribute(name) { attributes.splice(attributes.findIndex(a => a.name === name), 1) },\n    // setAttributeNode() { }\n  }\n}\n\nexport default sprae\n", "import sprae, { dir, _state, _on, _off, frag } from \"../core.js\";\n\n// :if is interchangeable with :each depending on order, :if :each or :each :if have different meanings\n// as for :if :with - :if must init first, since it is lazy, to avoid initializing component ahead of time by :with\n// we consider :with={x} :if={x} case insignificant\nconst _prevIf = Symbol(\"if\");\n\ndir('if', (el, state) => {\n  let holder = document.createTextNode('')\n\n  let nextEl = el.nextElementSibling,\n    curEl, ifEl, elseEl;\n\n  el.replaceWith(holder)\n\n  ifEl = el.content ? frag(el) : el\n  ifEl[_state] = null // mark el as fake-spraed to hold-on init, since we sprae rest when branch matches\n\n  // FIXME: instead of nextEl / el we should use elseEl / ifEl\n  if (nextEl?.hasAttribute(\":else\")) {\n    nextEl.removeAttribute(\":else\");\n    // if nextEl is :else :if - leave it for its own :if handler\n    if (!nextEl.hasAttribute(\":if\")) nextEl.remove(), elseEl = nextEl.content ? frag(nextEl) : nextEl, elseEl[_state] = null\n  }\n  else nextEl = null\n\n  return (value, newEl = el[_prevIf] ? null : value ? ifEl : elseEl) => {\n    if (nextEl) nextEl[_prevIf] = el[_prevIf] || newEl == ifEl\n    if (curEl != newEl) {\n      // disable effects on child elements when element is not matched\n      if (curEl) curEl.remove(), curEl[_off]?.();\n      if (curEl = newEl) {\n        holder.before(curEl.content || curEl)\n        // remove fake memo to sprae as new\n        curEl[_state] === null ? (delete curEl[_state], sprae(curEl, state))\n        // enable effects if branch is matched\n        : curEl[_on]()\n      }\n    }\n  };\n})\n", "import sprae, { _state, dir, frag, parse } from \"../core.js\";\nimport store, { _change, _signals } from \"../store.js\";\nimport { effect } from '../signal.js';\n\n\ndir('each', (tpl, state, expr) => {\n    let [itemVar, idxVar = \"$\"] = expr.split(/\\bin\\b/)[0].trim().split(/\\s*,\\s*/);\n\n    // we need :if to be able to replace holder instead of tpl for :if :each case\n    let holder = document.createTextNode(\"\");\n\n    // we re-create items any time new items are produced\n    let cur, keys, items, prevl = 0\n\n    let update = () => {\n      let i = 0, newItems = items, newl = newItems.length\n\n      // plain array update, not store (signal with array) - updates full list\n      if (cur && !cur[_change]) {\n        for (let s of cur[_signals] || []) s[Symbol.dispose]()\n        cur = null, prevl = 0\n      }\n\n      // delete\n      if (newl < prevl) cur.length = newl\n\n      // update, append, init\n      else {\n        // init\n        if (!cur) cur = newItems\n        // update\n        else while (i < prevl) cur[i] = newItems[i++]\n\n        // append\n        for (; i < newl; i++) {\n          cur[i] = newItems[i]\n          let idx = i,\n            // FIXME: inherited state is cheaper in terms of memory and faster in terms of performance\n            // compared to cloning all parent signals and creating a proxy\n            // FIXME: besides try to avoid _signals access: we can optimize store then not checking for _signals key\n            scope = store({\n              [itemVar]: cur[_signals]?.[idx] || cur[idx],\n              [idxVar]: keys ? keys[idx] : idx\n            }, state),\n\n            el = tpl.content ? frag(tpl) : tpl.cloneNode(true);\n\n          holder.before(el.content || el);\n          sprae(el, scope);\n\n          // signal/holder disposal removes element\n          let _prev = ((cur[_signals] ||= [])[i] ||= {})[Symbol.dispose]\n          cur[_signals][i][Symbol.dispose] = () => {\n            _prev?.(), el[Symbol.dispose]?.(), el.remove()\n          };\n        }\n      }\n\n      prevl = newl\n    }\n\n    tpl.replaceWith(holder);\n    tpl[_state] = null // mark as fake-spraed, to preserve :-attribs for template\n\n    return value => {\n      // obtain new items\n      keys = null\n      if (typeof value === \"number\") items = Array.from({ length: value }, (_, i) => i + 1)\n      else if (value?.constructor === Object) keys = Object.keys(value), items = Object.values(value)\n      else items = value || []\n\n      // whenever list changes, we rebind internal change effect\n      let planned = 0\n      return effect(() => {\n        // subscribe to items change (.length) - we do it every time (not just in update) since preact unsubscribes unused signals\n        items[_change]?.value\n\n        // make first render immediately, debounce subsequent renders\n        if (!planned++) update(), queueMicrotask(() => (planned > 1 && update(), planned = 0));\n      })\n    }\n  },\n\n  // redefine evaluator to take second part of expression\n  expr => parse(expr.split(/\\bin\\b/)[1])\n)\n", "import { dir, parse } from \"../core.js\";\nimport { untracked } from \"../signal.js\";\nimport { setter } from \"../store.js\";\n\ndir('ref', (el, state, expr) => (\n  typeof parse(expr)(state) == 'function' ?\n    v => v.call(null, el) :\n    (setter(expr)(state, el), _ => _)\n))\n", "import sprae, { dir } from \"../core.js\";\nimport { untracked } from \"../signal.js\";\nimport store, { _signals } from '../store.js';\n\ndir('with', (el, rootState, state) => (\n  state=null,\n  values => !state ?\n    // NOTE: we force untracked because internal directives can eval outside of effects (like ref etc) that would cause unwanted subscribe\n    // FIXME: since this can be async effect, we should create & sprae it in advance.\n    untracked(() => sprae(el, state = store(values, rootState))) :\n    sprae(el, values)\n))\n", "import { dir, frag } from \"../core.js\";\n\ndir('text', el => (\n  // <template :text=\"a\"/> or previously initialized template\n  el.content && el.replaceWith(el = frag(el).childNodes[0]),\n  value => el.textContent = value == null ? \"\" : value\n))\n", "import { dir } from \"../core.js\";\n\ndir('class', (el, cur) => (\n  cur = new Set,\n  v => {\n    let clsx = new Set;\n    if (v) {\n      if (typeof v === \"string\") v.split(' ').map(cls => clsx.add(cls));\n      else if (Array.isArray(v)) v.map(v => v && clsx.add(v));\n      else Object.entries(v).map(([k, v]) => v && clsx.add(k));\n    }\n    for (let cls of cur) if (clsx.has(cls)) clsx.delete(cls); else el.classList.remove(cls);\n    for (let cls of cur = clsx) el.classList.add(cls)\n  })\n)\n", "import { dir } from \"../core.js\";\n\ndir('style', (el, initStyle) => (\n  initStyle = el.getAttribute(\"style\"),\n  v => {\n    if (typeof v === \"string\") el.setAttribute(\"style\", initStyle + (initStyle.endsWith(';') ? '' : '; ') + v);\n    else {\n      if (initStyle) el.setAttribute(\"style\", initStyle);\n      for (let k in v) k[0] == '-' ? (el.style.setProperty(k, v[k])) : el.style[k] = v[k]\n    }\n  })\n)\n", "// generic property directive\nimport { dir, err } from \"../core.js\";\n\ndir('default', (target, state, expr, name) => {\n  // simple prop\n  if (!name.startsWith('on'))\n    return name ?\n      value => attr(target, name, value) :\n      value => { for (let key in value) attr(target, dashcase(key), value[key]) };\n\n  // bind event to a target\n  // NOTE: if you decide to remove chain of events, thing again - that's unique feature of sprae, don't diminish your own value.\n  // ona..onb\n  let ctxs = name.split('..').map(e => {\n    let ctx = { evt: '', target, test: () => true };\n    ctx.evt = (e.startsWith('on') ? e.slice(2) : e).replace(/\\.(\\w+)?-?([-\\w]+)?/g,\n      (_, mod, param = '') => (ctx.test = mods[mod]?.(ctx, ...param.split('-')) || ctx.test, '')\n    );\n    return ctx;\n  });\n\n  // add listener with the context\n  let addListener = (fn, { evt, target, test, defer, stop, prevent, immediate, ...opts }, cb) => {\n    if (defer) fn = defer(fn)\n\n    cb = (e) => {\n      try {\n        test(e) && (stop && (immediate ? e.stopImmediatePropagation() : e.stopPropagation()), prevent && e.preventDefault(), fn?.call(state, e))\n      } catch (error) { err(error, `:on${evt}`, fn) }\n    };\n\n    target.addEventListener(evt, cb, opts)\n    return () => target.removeEventListener(evt, cb, opts)\n  };\n\n  // single event\n  if (ctxs.length == 1) return v => addListener(v, ctxs[0])\n\n  // events cycler\n  let startFn, nextFn, off, idx = 0\n  let nextListener = (fn) => {\n    off = addListener((e) => (\n      off(), nextFn = fn?.(e), (idx = ++idx % ctxs.length) ? nextListener(nextFn) : (startFn && nextListener(startFn))\n    ), ctxs[idx]);\n  }\n\n  return value => (\n    startFn = value,\n    !off && nextListener(startFn),\n    () => startFn = null // nil startFn to autodispose chain\n  )\n})\n\n// event modifiers\nconst mods = {\n  // actions\n  prevent(ctx) { ctx.prevent = true; },\n  stop(ctx) { ctx.stop = true; },\n  immediate(ctx) { ctx.immediate = true; },\n\n  // options\n  once(ctx) { ctx.once = true; },\n  passive(ctx) { ctx.passive = true; },\n  capture(ctx) { ctx.capture = true; },\n\n  // target\n  window(ctx) { ctx.target = window; },\n  document(ctx) { ctx.target = document; },\n  parent(ctx) { ctx.target = ctx.target.parentNode; },\n\n  throttle(ctx, limit=108) { ctx.defer = (fn) => throttle(fn, limit)},\n  debounce(ctx, wait=108) { ctx.defer = (fn) => debounce(fn, wait) },\n\n  // test\n  outside: (ctx) => (e) => {\n    let target = ctx.target;\n    if (target.contains(e.target)) return false;\n    if (e.target.isConnected === false) return false;\n    if (target.offsetWidth < 1 && target.offsetHeight < 1) return false;\n    return true;\n  },\n  self: (ctx) => (e) => e.target === ctx.target,\n\n  // keyboard\n  ctrl: (_, ...param) => (e) => keys.ctrl(e) && param.every((p) => (keys[p] ? keys[p](e) : e.key === p)),\n  shift: (_, ...param) => (e) => keys.shift(e) && param.every((p) => (keys[p] ? keys[p](e) : e.key === p)),\n  alt: (_, ...param) => (e) => keys.alt(e) && param.every((p) => (keys[p] ? keys[p](e) : e.key === p)),\n  meta: (_, ...param) => (e) => keys.meta(e) && param.every((p) => (keys[p] ? keys[p](e) : e.key === p)),\n  // NOTE: we don't expose up/left/right/down as too verbose: can and better be handled/differentiated at once\n  arrow: () => keys.arrow,\n  enter: () => keys.enter,\n  esc: () => keys.esc,\n  tab: () => keys.tab,\n  space: () => keys.space,\n  delete: () => keys.delete,\n  digit: () => keys.digit,\n  letter: () => keys.letter,\n  char: () => keys.char,\n};\n\n// key testers\nconst keys = {\n  ctrl: (e) => e.ctrlKey || e.key === \"Control\" || e.key === \"Ctrl\",\n  shift: (e) => e.shiftKey || e.key === \"Shift\",\n  alt: (e) => e.altKey || e.key === \"Alt\",\n  meta: (e) => e.metaKey || e.key === \"Meta\" || e.key === \"Command\",\n  arrow: (e) => e.key.startsWith(\"Arrow\"),\n  enter: (e) => e.key === \"Enter\",\n  esc: (e) => e.key.startsWith(\"Esc\"),\n  tab: (e) => e.key === \"Tab\",\n  space: (e) => e.key === \"\u00A0\" || e.key === \"Space\" || e.key === \" \",\n  delete: (e) => e.key === \"Delete\" || e.key === \"Backspace\",\n  digit: (e) => /^\\d$/.test(e.key),\n  letter: (e) => /^\\p{L}$/gu.test(e.key),\n  char: (e) => /^\\S$/.test(e.key),\n};\n\n// create delayed fns\nconst throttle = (fn, limit) => {\n  let pause, planned,\n    block = (e) => {\n      pause = true;\n      setTimeout(() => {\n        pause = false;\n        // if event happened during blocked time, it schedules call by the end\n        if (planned) return (planned = false), block(e), fn(e);\n      }, limit);\n    };\n  return (e) => {\n    if (pause) return (planned = true);\n    block(e);\n    return fn(e);\n  };\n};\n\nconst debounce = (fn, wait) => {\n  let timeout;\n  return (e) => {\n    clearTimeout(timeout);\n    timeout = setTimeout(() => {\n      timeout = null;\n      fn(e);\n    }, wait);\n  };\n};\n\n// set attr\nexport const attr = (el, name, v) => {\n  if (v == null || v === false) el.removeAttribute(name);\n  else el.setAttribute(name, v === true ? \"\" : typeof v === \"number\" || typeof v === \"string\" ? v : \"\");\n}\n\nexport const dashcase = (str) => {\n  return str.replace(/[A-Z\\u00C0-\\u00D6\\u00D8-\\u00DE]/g, (match, i) => (i ? '-' : '') + match.toLowerCase());\n}\n", "import sprae, { parse } from \"../core.js\";\nimport { dir } from \"../core.js\";\nimport { untracked } from \"../signal.js\";\nimport { setter } from \"../store.js\";\nimport { attr } from './default.js';\n\n\ndir('value', (el, state, expr) => {\n  const update =\n    (el.type === \"text\" || el.type === \"\") ?\n      (value) => el.setAttribute(\"value\", (el.value = value == null ? \"\" : value)) :\n      (el.tagName === \"TEXTAREA\" || el.type === \"text\" || el.type === \"\") ?\n        (value, from, to) => (\n          // we retain selection in input\n          (from = el.selectionStart),\n          (to = el.selectionEnd),\n          el.setAttribute(\"value\", (el.value = value == null ? \"\" : value)),\n          from && el.setSelectionRange(from, to)\n        ) :\n        (el.type === \"checkbox\") ?\n          (value) => (el.checked = value, attr(el, \"checked\", value)) :\n          (el.type === \"select-one\") ?\n            (value) => {\n              for (let o of el.options)\n                o.value == value ? o.setAttribute(\"selected\", '') : o.removeAttribute(\"selected\");\n              el.value = value;\n            } :\n            (el.type === 'select-multiple') ? (value) => {\n              for (let o of el.options) o.removeAttribute('selected')\n              for (let v of value) el.querySelector(`[value=\"${v}\"]`).setAttribute('selected', '')\n            } :\n              (value) => (el.value = value);\n\n  // bind back to value, but some values can be not bindable, eg. `:value=\"7\"`\n  try {\n    const set = setter(expr)\n    const handleChange = el.type === 'checkbox' ? () => set(state, el.checked) :\n      el.type === 'select-multiple' ? () => set(state, [...el.selectedOptions].map(o => o.value)) :\n        () => set(state, el.selectedIndex < 0 ? null : el.value)\n\n    el.oninput = el.onchange = handleChange; // hope user doesn't redefine these manually via `.oninput = somethingElse` - it saves 5 loc vs addEventListener\n\n    if (el.type?.startsWith('select')) {\n      // select element also must observe any added/removed options or changed values (outside of sprae)\n      new MutationObserver(handleChange).observe(el, { childList: true, subtree: true, attributes: true });\n\n      // select options must be initialized before calling an update\n      sprae(el, state)\n    }\n\n    // initial state value\n    parse(expr)(state) ?? handleChange()\n  } catch {}\n\n  return update\n})\n", "import { dir } from \"../core.js\";\n\ndir('fx', _ => _ => _)\n", "import { dir } from \"../core.js\";\nimport { attr, dashcase } from './default.js'\n\ndir('aria', (el) => value => {\n  for (let key in value) attr(el, 'aria-' + dashcase(key), value[key] == null ? null : value[key] + '')\n})\n", "import { dir } from \"../core.js\";\n\ndir('data', el => value => {for (let key in value) el.dataset[key] = value[key];})\n", "import sprae from './core.js'\n\n// default directives\nimport './directive/if.js'\nimport './directive/each.js'\nimport './directive/ref.js'\nimport './directive/with.js'\nimport './directive/text.js'\nimport './directive/class.js'\nimport './directive/style.js'\nimport './directive/value.js'\nimport './directive/fx.js'\nimport './directive/default.js'\nimport './directive/aria.js'\nimport './directive/data.js'\n\n// default compiler (indirect new Function to avoid detector)\nsprae.use({ compile: expr => sprae.constructor(`with (arguments[0]) { return ${expr} };`) })\n\nexport default sprae\n", "var sprae = require(\"./sprae.js\").default;\nsprae.store = require(\"./store.js\").default;\nmodule.exports = sprae;"],
  "mappings": "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",
  "names": ["set", "name", "el", "dir", "keys", "v", "target", "set", "_", "sprae"]
}
