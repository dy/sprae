{
  "version": 3,
  "sources": ["../signal.js", "../store.js", "../core.js", "../directive/if.js", "../directive/each.js", "../directive/ref.js", "../directive/with.js", "../directive/text.js", "../directive/class.js", "../directive/style.js", "../directive/default.js", "../directive/value.js", "../directive/fx.js", "../directive/aria.js", "../directive/data.js", "../sprae.js", "../sprae.umd.cjs"],
  "sourcesContent": ["// ulive copy, stable minimal implementation\nlet current, batched;\n\nexport let signal = (v, s, obs = new Set) => (\n  s = {\n    get value() {\n      current?.deps.push(obs.add(current));\n      return v\n    },\n    set value(val) {\n      if (val === v) return\n      v = val;\n      for (let sub of obs) batched ? batched.add(sub) : sub(); // notify effects\n    },\n    peek() { return v },\n  },\n  s.toJSON = s.then = s.toString = s.valueOf = () => s.value,\n  s\n),\n  effect = (fn, teardown, fx, deps) => (\n    fx = (prev) => {\n      teardown?.call?.();\n      prev = current, current = fx;\n      try { teardown = fn(); } finally { current = prev; }\n    },\n    deps = fx.deps = [],\n\n    fx(),\n    (dep) => { teardown?.call?.(); while (dep = deps.pop()) dep.delete(fx); }\n  ),\n  computed = (fn, s = signal(), c, e) => (\n    c = {\n      get value() {\n        e ||= effect(() => s.value = fn());\n        return s.value\n      },\n      peek: s.peek\n    },\n    c.toJSON = c.then = c.toString = c.valueOf = () => c.value,\n    c\n  ),\n  batch = (fn) => {\n    let fxs = batched;\n    if (!fxs) batched = new Set;\n    try { fn(); }\n    finally {\n      if (!fxs) {\n        fxs = batched;\n        batched = null;\n        for (const fx of fxs) fx();\n      }\n    }\n  },\n  untracked = (fn, prev, v) => (prev = current, current = null, v = fn(), current = prev, v);\n\n// signals adapter - allows switching signals implementation and not depend on core\n\nexport function use(s) {\n  signal = s.signal\n  effect = s.effect\n  computed = s.computed\n  batch = s.batch || (fn => fn())\n  untracked = s.untracked || batch\n}\n", "// signals-based proxy\nimport { signal, computed, batch, untracked } from './signal.js'\n\nexport const _signals = Symbol('signals'), _change = Symbol('length');\n\n// object store is not lazy\nexport default function store(values, parent) {\n  if (!values) return values\n\n  // ignore existing state as argument\n  if (values[_signals]) return values;\n\n  // redirect for optimized array store\n  if (Array.isArray(values)) return list(values)\n\n  // ignore non-objects or custom objects\n  if (values.constructor !== Object || values[Symbol.toStringTag]) return values;\n\n  // NOTE: if you decide to unlazy values, think about large arrays - init upfront can be costly\n  let signals = { ...parent?.[_signals] }, _len = signal(Object.values(values).length)\n\n  // proxy conducts prop access to signals\n  const state = new Proxy(signals, {\n    get: (_, key) => key === _change ? _len : key === _signals ? signals : signals[key]?.valueOf(),\n    set: (_, key, v, s) => (s = signals[key], set(signals, key, v), s ?? (++_len.value), 1), // bump length for new signal\n    deleteProperty: (_, key) => (signals[key] && (del(signals, key), _len.value--), 1),\n    ownKeys() {\n      // subscribe to length when object is spread\n      _len.value\n      return Reflect.ownKeys(signals);\n    },\n  })\n\n  // init signals for values\n  for (let key in values) {\n    const desc = Object.getOwnPropertyDescriptor(values, key)\n\n    // getter turns into computed\n    if (desc?.get) {\n      // stash setter\n      (signals[key] = computed(desc.get.bind(state)))._set = desc.set?.bind(state);\n    }\n    else {\n      // init blank signal - make sure we don't take prototype one\n      signals[key] = undefined\n      set(signals, key, values[key]);\n    }\n  }\n\n  return state\n}\n\n// length changing methods\nconst mut = { push: 1, pop: 1, shift: 1, unshift: 1, splice: 1 }\n\n// array store - signals are lazy since arrays can be very large & expensive\nexport function list(values) {\n  // track last accessed property to find out if .length was directly accessed from expression or via .push/etc method\n  let lastProp\n\n  // ignore existing state as argument\n  if (values[_signals]) return values;\n\n  // .length signal is stored separately, since it cannot be replaced on array\n  let _len = signal(values.length),\n    // gotta fill with null since proto methods like .reduce may fail\n    signals = Array(values.length).fill();\n\n  // proxy conducts prop access to signals\n  const state = new Proxy(signals, {\n    get(_, key) {\n      // covers Symbol.isConcatSpreadable etc.\n      if (typeof key === 'symbol') return key === _change ? _len : key === _signals ? signals : signals[key]\n\n      // if .length is read within .push/etc - peek signal to avoid recursive subscription\n      if (key === 'length') return mut[lastProp] ? _len.peek() : _len.value;\n\n      lastProp = key;\n\n      if (signals[key]) return signals[key].valueOf()\n\n      // I hope reading values here won't diverge from signals\n      if (key < signals.length) return (signals[key] = signal(store(values[key]))).value\n    },\n\n    set(_, key, v) {\n      // .length\n      if (key === 'length') {\n        // force cleaning up tail\n        for (let i = v, l = signals.length; i < l; i++) delete state[i]\n        // .length = N directly\n        _len.value = signals.length = v;\n        return true\n      }\n\n      set(signals, key, v)\n\n      // force changing length, if eg. a=[]; a[1]=1 - need to come after setting the item\n      if (key >= _len.peek()) _len.value = signals.length = Number(key) + 1\n\n      return true\n    },\n\n    deleteProperty: (_, key) => (signals[key] && del(signals, key), 1),\n\n  })\n\n  return state\n}\n\n// set/update signal value\nfunction set(signals, key, v) {\n  let s = signals[key]\n\n  // untracked\n  if (key[0] === '_') signals[key] = v\n  // new property\n  else if (!s) {\n    // preserve signal value as is\n    signals[key] = s = v?.peek ? v : signal(store(v))\n  }\n  // skip unchanged (although can be handled by last condition - we skip a few checks this way)\n  else if (v === s.peek());\n  // stashed _set for value with getter/setter\n  else if (s._set) s._set(v)\n  // patch array\n  else if (Array.isArray(v) && Array.isArray(s.peek())) {\n    const cur = s.peek()\n    // if we update plain array (stored in signal) - take over value instead\n    if (cur[_change]) untracked(() => {\n      batch(() => {\n        let i = 0, l = v.length;\n        for (; i < l; i++) cur[i] = v[i]\n        cur.length = l // forces deleting tail signals\n      })\n    })\n    else {\n      s.value = v\n    }\n  }\n  // .x = y\n  else {\n    s.value = store(v)\n  }\n}\n\n// delete signal\nfunction del(signals, key) {\n  const s = signals[key], del = s[Symbol.dispose]\n  if (del) delete s[Symbol.dispose]\n  delete signals[key]\n  del?.()\n}\n", "import { use, effect } from \"./signal.js\";\nimport store, { _signals } from './store.js';\n\n// polyfill\nconst _dispose = (Symbol.dispose ||= Symbol(\"dispose\"));\n\n\n// reserved directives - order matters!\nexport const directive = {};\n\n// every element that's in cache === directly spraed and un subsequent sprae is just updated (like each)\nexport const memo = new WeakMap();\n\n// sprae element: apply directives\nexport default function sprae(el, values) {\n  // text nodes, comments etc\n  if (!el?.childNodes) return\n\n  // repeated call can be caused by :each with new objects with old keys needs an update\n  if (memo.has(el)) {\n    // we rewrite signals instead of update, because user should have what he provided\n    return Object.assign(memo.get(el), values)\n  }\n\n  // take over existing state instead of creating clone\n  const state = store(values || {}), disposes = []\n\n  init(el);\n\n  // if element was spraed by :with or :each instruction - skip, otherwise save\n  if (!memo.has(el)) memo.set(el, state);\n\n  // disposer unspraes all internal elements\n  el[_dispose] = () => {\n    while (disposes.length) disposes.pop()();\n    memo.delete(el);\n    el[_dispose] = null;\n  }\n\n  return state;\n\n  function init(el, parent = el.parentNode) {\n    if (!el.childNodes) return // ignore text nodes, comments etc\n    // init generic-name attributes second\n    for (let i = 0; i < el.attributes?.length;) {\n      let attr = el.attributes[i];\n\n      if (attr.name[0] === ':') {\n        el.removeAttribute(attr.name);\n\n        // multiple attributes like :id:for=\"\"\n        let names = attr.name.slice(1).split(':')\n\n        for (let name of names) {\n          let dir = directive[name] || directive.default\n          let evaluate = (dir.parse || parse)(attr.value)\n          let fn = dir(el, evaluate, state, name);\n          if (fn) disposes.push(effect(fn))\n          disposes.push(() => el.setAttributeNode(attr)) // recover attribute\n        }\n\n        // stop if element was spraed by internal directive\n        if (memo.has(el)) return el[_dispose] && disposes.push(el[_dispose])\n\n        // stop if element is skipped/detached like in case of :if or :each\n        if (el.parentNode !== parent) return\n      } else i++;\n    }\n\n    for (let child of [...el.childNodes])\n      // adjust for template container - parent is overlooked\n      init(child, el.content ? el.childNodes[0].parentNode : el);\n  };\n}\n\n\n// parse expression into evaluator fn\nconst evalMemo = {};\nexport const parse = (expr, dir, fn) => {\n  if (fn = evalMemo[expr = expr.trim()]) return fn\n\n  // static-time errors\n  try { fn = compile(expr) }\n  catch (e) { err(e, dir, expr) }\n\n  // runtime errors\n  return evalMemo[expr] = fn\n}\n\n// wrapped call\nexport const err = (e, dir, expr = '') => {\n  throw Object.assign(e, { message: `\u2234 ${e.message}\\n\\n${dir}${expr ? `=\"${expr}\"\\n\\n` : \"\"}`, expr })\n}\n\nexport let compile\n\n// configure signals/compile\n// it's more compact than using sprae.signal = signal etc.\nsprae.use = s => {\n  s.signal && use(s);\n  s.compile && (compile = s.compile);\n}\n\n\n// instantiated <template> fragment holder, like persisting fragment but with minimal API surface\nexport const frag = (tpl) => {\n  if (!tpl.nodeType) return tpl // existing tpl\n\n  let content = tpl.content.cloneNode(true),\n    attributes = [...tpl.attributes],\n    ref = document.createTextNode(''),\n    // ensure at least one node\n    childNodes = (content.append(ref), [...content.childNodes])\n\n  return {\n    // get parentNode() { return childNodes[0].parentNode },\n    childNodes,\n    content,\n    remove: () => content.append(...childNodes),\n    replaceWith(el) {\n      if (el === ref) return\n      ref.before(el)\n      content.append(...childNodes)\n    },\n    attributes,\n    removeAttribute(name) { attributes.splice(attributes.findIndex(a => a.name === name), 1) },\n    setAttributeNode() { }\n  }\n}\n", "import sprae, { directive, memo, frag } from \"../core.js\";\n\n// :if is interchangeable with :each depending on order, :if :each or :each :if have different meanings\n// as for :if :with - :if must init first, since it is lazy, to avoid initializing component ahead of time by :with\n// we consider :with={x} :if={x} case insignificant\nconst _prevIf = Symbol(\"if\");\ndirective.if = (el, evaluate, state) => {\n  let next = el.nextElementSibling,\n    holder = document.createTextNode(''),\n    curEl, ifEl, elseEl;\n\n  el.replaceWith(holder)\n\n  ifEl = el.content ? frag(el) : el\n  memo.set(ifEl, null) // mark all el as fake-spraed, because we have to sprae for real on insert\n\n  if (next?.hasAttribute(\":else\")) {\n    next.removeAttribute(\":else\");\n    // if next is :else :if - leave it for its own :if handler\n    if (!next.hasAttribute(\":if\")) next.remove(), elseEl = next.content ? frag(next) : next, memo.set(elseEl, null)\n  }\n\n  return () => {\n    const newEl = evaluate(state) ? ifEl : el[_prevIf] ? null : elseEl;\n    if (next) next[_prevIf] = newEl === ifEl\n    if (curEl != newEl) {\n      // disable effects on child elements to avoid internal effects from triggering on value changes when element's not matched\n      if (curEl) curEl.remove(), curEl[Symbol.dispose]?.();\n      if (curEl = newEl) {\n        holder.before(curEl.content || curEl)\n        memo.get(curEl) === null && memo.delete(curEl) // remove fake memo to sprae as new\n        sprae(curEl, state)\n      }\n    }\n  };\n};\n", "import sprae, { directive, frag, parse } from \"../core.js\";\nimport store, { _change, _signals } from \"../store.js\";\nimport { untracked, computed } from '../signal.js';\n\n\ndirective.each = (tpl, [itemVar, idxVar, evaluate], state) => {\n  // we need :if to be able to replace holder instead of tpl for :if :each case\n  const holder = (document.createTextNode(\"\"));\n  tpl.replaceWith(holder);\n\n  // we re-create items any time new items are produced\n  let cur, keys, prevl = 0\n\n  // separate computed effect reduces number of needed updates for the effect\n  const items = computed(() => {\n    keys = null\n    let items = evaluate(state)\n    if (typeof items === \"number\") items = Array.from({ length: items }, (_, i) => i + 1)\n    if (items?.constructor === Object) keys = Object.keys(items), items = Object.values(items)\n    return items || []\n  })\n\n  const update = () => {\n    // NOTE: untracked avoids rerendering full list whenever internal items or props change\n    untracked(() => {\n      let i = 0, newItems = items.value, newl = newItems.length\n\n      // plain array update, not store (signal with array) - updates full list\n      if (cur && !(cur[_change])) {\n        for (let s of cur[_signals] || []) { s[Symbol.dispose]() }\n        cur = null, prevl = 0\n      }\n\n      // delete\n      if (newl < prevl) {\n        cur.length = newl\n      }\n      // update, append, init\n      else {\n        // init\n        if (!cur) {\n          cur = newItems\n        }\n        // update\n        else {\n          for (; i < prevl; i++) {\n            cur[i] = newItems[i]\n          }\n        }\n\n        // append\n        for (; i < newl; i++) {\n          cur[i] = newItems[i]\n          let idx = i,\n            scope = store({\n              [itemVar]: cur[_signals]?.[idx] || cur[idx],\n              [idxVar]: keys ? keys[idx] : idx\n            }, state),\n            el = tpl.content ? frag(tpl) : tpl.cloneNode(true);\n\n          holder.before(el.content || el);\n          sprae(el, scope);\n\n          // signal/holder disposal removes element\n          ((cur[_signals] ||= [])[i] ||= {})[Symbol.dispose] = () => {\n            el[Symbol.dispose]?.(), el.remove()\n          };\n        }\n      }\n\n      prevl = newl\n    })\n  }\n\n  let planned = 0\n  return () => {\n    // subscribe to items change (.length) - we do it every time (not just on init) since preact unsubscribes unused signals\n    items.value[_change]?.value\n\n    // make first render immediately, debounce subsequent renders\n    if (!planned) {\n      update()\n      queueMicrotask(() => (planned && update(), planned = 0))\n    } else planned++\n  }\n}\n\n\n// redefine parser to exclude `[a in] b`\ndirective.each.parse = (expr) => {\n  let [leftSide, itemsExpr] = expr.split(/\\s+in\\s+/);\n  let [itemVar, idxVar = \"$\"] = leftSide.split(/\\s*,\\s*/);\n\n  return [itemVar, idxVar, parse(itemsExpr)]\n}\n", "import { directive } from \"../core.js\";\n\n// ref must be last within primaries, since that must be skipped by :each, but before secondaries\ndirective.ref = (el, evaluate, state) => {\n  return () => evaluate(state)?.call?.(null, el)\n}\n", "import sprae, { directive } from \"../core.js\";\nimport store, { _signals } from '../store.js';\n\ndirective.with = (el, evaluate, rootState) => {\n  let state\n  return () => {\n    let values = evaluate(rootState);\n    sprae(el, state ? values : state = store(values, rootState))\n  }\n};\n", "import { directive, frag } from \"../core.js\";\n\n// set text content\ndirective.text = (el, evaluate, state) => {\n  // <template :text=\"a\"/> or previously initialized template\n  if (el.content) el.replaceWith(el = frag(el).childNodes[0])\n\n  return () => {\n    let value = evaluate(state);\n    el.textContent = value == null ? \"\" : value;\n  };\n};\n", "import { directive } from \"../core.js\";\n\ndirective.class = (el, evaluate, state) => {\n  let cur = new Set\n  return () => {\n    let v = evaluate(state);\n    let clsx = new Set;\n    if (v) {\n      if (typeof v === \"string\") v.split(' ').map(cls => clsx.add(cls));\n      else if (Array.isArray(v)) v.map(v => v && clsx.add(v));\n      else Object.entries(v).map(([k, v]) => v && clsx.add(k));\n    }\n    for (let cls of cur) if (clsx.has(cls)) clsx.delete(cls); else el.classList.remove(cls);\n    for (let cls of cur = clsx) el.classList.add(cls)\n  };\n};\n", "import { directive } from \"../core.js\";\n\ndirective.style = (el, evaluate, state) => {\n  let initStyle = el.getAttribute(\"style\");\n\n  return () => {\n    let v = evaluate(state);\n    if (typeof v === \"string\") el.setAttribute(\"style\", initStyle + (initStyle.endsWith(';') ? '' : '; ') + v);\n    else {\n      if (initStyle) el.setAttribute(\"style\", initStyle);\n      for (let k in v) k[0] == '-' ? (el.style.setProperty(k, v[k])) : el.style[k] = v[k]\n    }\n  };\n};\n", "import { directive, err } from \"../core.js\";\n\n// set generic property directive\ndirective.default = (target, evaluate, state, name) => {\n  // simple prop\n  if (!name.startsWith('on')) return () => {\n    let value = evaluate(state);\n    if (name) attr(target, name, value)\n    else for (let key in value) attr(target, dashcase(key), value[key]);\n  };\n\n  // bind event to a target\n  // NOTE: if you decide to remove chain of events, thing again - that's unique feature of sprae, don't diminish your own value.\n  // ona..onb\n  const ctxs = name.split('..').map(e => {\n    let ctx = { evt: '', target, test: () => true };\n    ctx.evt = (e.startsWith('on') ? e.slice(2) : e).replace(/\\.(\\w+)?-?([-\\w]+)?/g,\n      (match, mod, param = '') => (ctx.test = mods[mod]?.(ctx, ...param.split('-')) || ctx.test, '')\n    );\n    return ctx;\n  });\n\n  // single event\n  if (ctxs.length == 1) return () => addListener(evaluate(state), ctxs[0])\n\n  // events cycler\n  let startFn, nextFn, off, idx = 0\n  const nextListener = (fn) => {\n    off = addListener((e) => (\n      off(), nextFn = fn?.(e), (idx = ++idx % ctxs.length) ? nextListener(nextFn) : (startFn && nextListener(startFn))\n    ), ctxs[idx]);\n  }\n\n  return () => (\n    startFn = evaluate(state),\n    !off && nextListener(startFn),\n    () => startFn = null // nil startFn to autodispose chain\n  )\n\n  // add listener with the context\n  function addListener(fn, { evt, target, test, defer, stop, prevent, immediate, ...opts }) {\n    if (defer) fn = defer(fn)\n\n    const cb = (e) => {\n      try {\n        test(e) && (stop && (immediate ? e.stopImmediatePropagation() : e.stopPropagation()), prevent && e.preventDefault(), fn?.(e))\n      } catch (error) { err(error, `:on${evt}`, fn) }\n    };\n\n    target.addEventListener(evt, cb, opts)\n    return () => target.removeEventListener(evt, cb, opts)\n  };\n\n};\n\n// event modifiers\nconst mods = {\n  // actions\n  prevent(ctx) { ctx.prevent = true; },\n  stop(ctx) { ctx.stop = true; },\n  immediate(ctx) { ctx.immediate = true; },\n\n  // options\n  once(ctx) { ctx.once = true; },\n  passive(ctx) { ctx.passive = true; },\n  capture(ctx) { ctx.capture = true; },\n\n  // target\n  window(ctx) { ctx.target = window; },\n  document(ctx) { ctx.target = document; },\n  parent(ctx) { ctx.target = ctx.target.parentNode; },\n\n  throttle(ctx, limit) { ctx.defer = (fn) => throttle(fn, limit ? Number(limit) || 0 : 108); },\n  debounce(ctx, wait) { ctx.defer = (fn) => debounce(fn, wait ? Number(wait) || 0 : 108); },\n\n  // test\n  outside: (ctx) => (e) => {\n    let target = ctx.target;\n    if (target.contains(e.target)) return false;\n    if (e.target.isConnected === false) return false;\n    if (target.offsetWidth < 1 && target.offsetHeight < 1) return false;\n    return true;\n  },\n  self: (ctx) => (e) => e.target === ctx.target,\n\n  // keyboard\n  ctrl: (_, ...param) => (e) => keys.ctrl(e) && param.every((p) => (keys[p] ? keys[p](e) : e.key === p)),\n  shift: (_, ...param) => (e) => keys.shift(e) && param.every((p) => (keys[p] ? keys[p](e) : e.key === p)),\n  alt: (_, ...param) => (e) => keys.alt(e) && param.every((p) => (keys[p] ? keys[p](e) : e.key === p)),\n  meta: (_, ...param) => (e) => keys.meta(e) && param.every((p) => (keys[p] ? keys[p](e) : e.key === p)),\n  // NOTE: we don't expose up/left/right/down as too verbose: can and better be handled/differentiated at once\n  arrow: () => keys.arrow,\n  enter: () => keys.enter,\n  esc: () => keys.esc,\n  tab: () => keys.tab,\n  space: () => keys.space,\n  delete: () => keys.delete,\n  digit: () => keys.digit,\n  letter: () => keys.letter,\n  char: () => keys.char,\n};\n\n// key testers\nconst keys = {\n  ctrl: (e) => e.ctrlKey || e.key === \"Control\" || e.key === \"Ctrl\",\n  shift: (e) => e.shiftKey || e.key === \"Shift\",\n  alt: (e) => e.altKey || e.key === \"Alt\",\n  meta: (e) => e.metaKey || e.key === \"Meta\" || e.key === \"Command\",\n  arrow: (e) => e.key.startsWith(\"Arrow\"),\n  enter: (e) => e.key === \"Enter\",\n  esc: (e) => e.key.startsWith(\"Esc\"),\n  tab: (e) => e.key === \"Tab\",\n  space: (e) => e.key === \"\u00A0\" || e.key === \"Space\" || e.key === \" \",\n  delete: (e) => e.key === \"Delete\" || e.key === \"Backspace\",\n  digit: (e) => /^\\d$/.test(e.key),\n  letter: (e) => /^\\p{L}$/gu.test(e.key),\n  char: (e) => /^\\S$/.test(e.key),\n};\n\n// set attr\nexport const attr = (el, name, v) => {\n  if (v == null || v === false) el.removeAttribute(name);\n  else el.setAttribute(name, v === true ? \"\" : typeof v === \"number\" || typeof v === \"string\" ? v : \"\");\n}\n\n// create delayed fns\nconst throttle = (fn, limit) => {\n  let pause, planned,\n    block = (e) => {\n      pause = true;\n      setTimeout(() => {\n        pause = false;\n        // if event happened during blocked time, it schedules call by the end\n        if (planned) return (planned = false), block(e), fn(e);\n      }, limit);\n    };\n  return (e) => {\n    if (pause) return (planned = true);\n    block(e);\n    return fn(e);\n  };\n};\n\nconst debounce = (fn, wait) => {\n  let timeout;\n  return (e) => {\n    clearTimeout(timeout);\n    timeout = setTimeout(() => {\n      timeout = null;\n      fn(e);\n    }, wait);\n  };\n};\n\nexport const dashcase = (str) => {\n  return str.replace(/[A-Z\\u00C0-\\u00D6\\u00D8-\\u00DE]/g, (match, i) => (i ? '-' : '') + match.toLowerCase());\n}\n", "import sprae from \"../core.js\";\nimport { directive, parse } from \"../core.js\";\nimport { attr } from './default.js';\n\n// connect expr to element value\ndirective.value = (el, [getValue, setValue], state) => {\n  const update =\n    (el.type === \"text\" || el.type === \"\") ?\n      (value) => el.setAttribute(\"value\", (el.value = value == null ? \"\" : value)) :\n      (el.tagName === \"TEXTAREA\" || el.type === \"text\" || el.type === \"\") ?\n        (value, from, to) => (\n          // we retain selection in input\n          (from = el.selectionStart),\n          (to = el.selectionEnd),\n          el.setAttribute(\"value\", (el.value = value == null ? \"\" : value)),\n          from && el.setSelectionRange(from, to)\n        ) :\n        (el.type === \"checkbox\") ?\n          (value) => (el.checked = value, attr(el, \"checked\", value)) :\n          (el.type === \"select-one\") ?\n            (value) => {\n              for (let o of el.options)\n                o.value == value ? o.setAttribute(\"selected\", '') : o.removeAttribute(\"selected\");\n              el.value = value;\n            } :\n            (el.type === 'select-multiple') ? (value) => {\n              for (let o of el.options) o.removeAttribute('selected')\n              for (let v of value) el.querySelector(`[value=\"${v}\"]`).setAttribute('selected', '')\n            } :\n              (value) => (el.value = value);\n\n  // bind ui back to value\n  const handleChange = el.type === 'checkbox' ? () => setValue(state, el.checked) : el.type === 'select-multiple' ? () => setValue(state, [...el.selectedOptions].map(o => o.value)) : (e) => setValue(state, el.selectedIndex < 0 ? null : el.value)\n\n  el.oninput = el.onchange = handleChange; // hope user doesn't redefine these manually via `.oninput = somethingElse` - it saves 5 loc vs addEventListener\n\n  if (el.type?.startsWith('select')) {\n    // select options must be initialized before calling an update\n    sprae(el, state)\n\n    // select element also must observe any added/removed options or changed values (outside of sprae)\n    new MutationObserver(handleChange).observe(el, { subtree: true, attributes: true });\n  }\n\n  return () => update(getValue(state));\n};\n\ndirective.value.parse = expr => {\n  let evaluate = [parse(expr)]\n  // catch wrong assigns like `123 =...`, `foo?.bar =...`\n  try {\n    const set = parse(`${expr}=__`);\n    // FIXME: if there's a simpler way to set value in justin?\n    evaluate.push((state, value) => {\n      state.__ = value\n      set(state, value)\n      delete state.__\n    })\n  }\n  catch (e) { }\n  return evaluate\n}\n", "import { directive } from \"../core.js\";\n\ndirective.fx = (el, evaluate, state) => {\n  return () => evaluate(state);\n};\n", "import { directive } from \"../core.js\";\nimport { attr, dashcase } from './default.js'\n\ndirective['aria'] = (el, evaluate, state) => {\n  const update = (value) => {\n    for (let key in value) attr(el, 'aria-' + dashcase(key), value[key] == null ? null : value[key] + '');\n  }\n  return () => update(evaluate(state))\n}\n", "import { directive } from \"../core.js\";\n\ndirective['data'] = (el, evaluate, state) => {\n  return () => {\n    let value = evaluate(state)\n    for (let key in value) el.dataset[key] = value[key];\n  }\n}\n", "import sprae from './core.js'\n\n// default directives\nimport './directive/if.js'\nimport './directive/each.js'\nimport './directive/ref.js'\nimport './directive/with.js'\nimport './directive/text.js'\nimport './directive/class.js'\nimport './directive/style.js'\nimport './directive/value.js'\nimport './directive/fx.js'\nimport './directive/default.js'\nimport './directive/aria.js'\nimport './directive/data.js'\n\n// default compiler (indirect new Function to avoid detector)\nsprae.use({ compile: expr => sprae.constructor(`with (arguments[0]) { return ${expr} };`) })\n\nexport default sprae\n", "// autonomous standalone sprae version - expected to run via CDN, CJS or AMD\n\nconst { default: sprae } = require(\"./sprae.js\");\n\n// expose global\nmodule.exports = sprae\n\n// autoinit if wanted\nconst init = document.currentScript?.getAttribute('init') || null\nif (init) sprae(document.documentElement, JSON.parse(init));\n"],
  "mappings": "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",
  "names": ["del", "init", "el", "attr", "keys", "items", "v", "target", "set", "sprae"]
}
