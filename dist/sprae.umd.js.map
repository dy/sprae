{
  "version": 3,
  "sources": ["../core.js", "../store.js", "../signal.js", "../directive/if.js", "../directive/else.js", "../directive/text.js", "../directive/class.js", "../directive/style.js", "../directive/fx.js", "../directive/value.js", "../directive/ref.js", "../directive/scope.js", "../directive/each.js", "../directive/default.js", "../directive/spread.js", "../sprae.js", "<stdin>"],
  "sourcesContent": ["import store, { _change, _signals } from \"./store.js\";\n\nexport const _dispose = (Symbol.dispose ||= Symbol(\"dispose\")),\n  _state = Symbol(\"state\"),\n  _on = Symbol('on'),\n  _off = Symbol('off'),\n  _add = Symbol('add');\n\n\nexport let prefix = ':', signal, effect, computed, batch = (fn) => fn(), untracked = batch;\n\nlet directive = {}, modifier = {}\n\n/**\n * Applies directives to an HTML element and manages its reactive state.\n *\n * @param {Element} [el=document.body] - The target HTML element to apply directives to.\n * @param {Object|store} [state] - Initial state values to populate the element's reactive state.\n * @returns {Object} The reactive state object associated with the element.\n */\nconst sprae = (el = document.body, state) => {\n  // repeated call can be caused by eg. :each with new objects with old keys\n  if (el[_state]) return Object.assign(el[_state], state)\n\n  // console.group('sprae', el.outerHTML)\n\n  // take over existing state instead of creating a clone\n  state = store(state || {})\n\n  let fx = [], offs = [], fn,\n    // FIXME: on generally needs to account for events, although we call it only in :if\n    on = () => (!offs && (offs = fx.map(fn => fn()))),\n    off = () => (offs?.map(off => off()), offs = null)\n\n  // on/off all effects\n  // we don't call prevOn as convention: everything defined before :else :if won't be disabled by :if\n  // imagine <x :onx=\"...\" :if=\"...\"/> - when :if is false, it disables directives after :if (calls _off) but ignores :onx\n  el[_on] = on\n  el[_off] = off\n\n  // destroy\n  el[_dispose] ||= () => (el[_off](), el[_off] = el[_on] = el[_dispose] = el[_state] = el[_add] = null)\n\n  const add = (el, _attrs = el.attributes) => {\n    // we iterate live collection (subsprae can init args)\n    if (_attrs) for (let i = 0; i < _attrs.length;) {\n      let { name, value } = _attrs[i]\n\n      if (name.startsWith(prefix)) {\n        el.removeAttribute(name)\n\n        // directive initializer can be redefined\n        fx.push(fn = initDirective(el, name, value, state))\n        offs.push(fn())\n\n        // stop after subsprae like :each, :if, :scope etc.\n        if (_state in el) return\n      } else i++\n    }\n\n    // :if and :each replace element with text node, which tweaks .children length, but .childNodes length persists\n    // for (let i = 0, child; i < (el.childNodes.length); i++) child =  el.childNodes[i], child.nodeType == 1 && add(child)\n    // FIXME: don't do spread here\n    for (let child of [...el.childNodes]) child.nodeType == 1 && add(child)\n  };\n\n  el[_add] = add;\n\n  add(el);\n\n  // if element was spraed by inline :with/:if/:each/etc instruction (meaning it has state placeholder) - skip, otherwise save _state\n  if (el[_state] === undefined) el[_state] = state\n\n  // console.groupEnd()\n\n  return state;\n}\n\n\n/**\n * Initializes directive (defined by sprae build), returns \"on\" function that enables it\n * Multiprop sequences initializer, eg. :a:b..c:d\n * @type {(el: HTMLElement, name:string, value:string, state:Object) => Function}\n * */\nconst initDirective = (el, attrName, expr, state) => {\n  let cur, // current step callback\n    off // current step disposal\n\n  // FIXME: separate cases: async, event, sequence, single attr\n\n  let steps = attrName.slice(prefix.length).split('..').map((step, i, { length }) => (\n    // multiple attributes like :id:for=\"\"\n    step.split(prefix).reduce((prev, str) => {\n      let [name, ...mods] = str.split('.'),\n        evaluate = parse(name, expr, directive[name]?.clean)\n\n      // events have no effects and can be sequenced\n      if (name.startsWith('on')) {\n        let type = name.slice(2),\n          first = e => (call(evaluate(state), e)),\n          fn = applyMods(\n            Object.assign(\n              // single event vs chain\n              length == 1 ? first :\n                e => (cur = (!i ? first : cur)(e), off(), off = steps[(i + 1) % length]()),\n              { target: el, type }\n            ),\n            mods);\n\n        return (_poff) => (_poff = prev?.(), fn.target.addEventListener(type, fn, fn), () => (_poff?.(), fn.target.removeEventListener(type, fn)))\n      }\n\n      // props have no sequences and can be sync\n      let update = (directive[name] || directive['*'])(el, state, expr, name)\n\n      // no-modifiers shortcut\n      if (!mods.length && !prev) return () => update && effect(() => (update(evaluate(state))))\n\n      let dispose,\n        change = signal(-1), // signal authorized to trigger effect: 0 = init; >0 = trigger\n        count = -1, // called effect count\n\n        // effect applier - first time it applies the effect, next times effect is triggered by change signal\n        // FIXME: init via dispose, don't reset count\n        fn = throttle(applyMods(() => {\n          if (++change.value) return // all calls except for the first one are handled by effect\n          dispose = effect(() => update && (\n            change.value == count ? fn() : // separate tick makes sure planner effect call is finished before real eval call\n              (count = change.value, update(evaluate(state))) // if changed more than effect called - call it\n          ));\n        }, mods))\n\n      return (_poff) => (\n        _poff = prev?.(),\n        // console.log('ON', name),\n        fn(),\n        ({\n          [name]: () => (\n            // console.log('OFF', name, el),\n            _poff?.(), dispose(), change.value = -1, count = dispose = null\n          )\n        })[name]\n      )\n    }, null)\n  ));\n\n  // off can be changed on the go\n  return () => (off = steps[0]())\n}\n\n\n/**\n * Configure sprae\n */\nexport const use = (s) => (\n  s.directive && (directive = s.directive),\n  s.modifier && (modifier = s.modifier),\n  s.compile && (compile = s.compile),\n  s.prefix && (prefix = s.prefix),\n  s.signal && (signal = s.signal),\n  s.effect && (effect = s.effect),\n  s.computed && (computed = s.computed),\n  s.batch && (batch = s.batch),\n  s.untracked && (untracked = s.untracked)\n)\n\n\n/**\n * Lifecycle hanger: makes DOM slightly slower but spraes automatically\n */\nexport const start = (root = document.body, values) => {\n  const state = store(values);\n  sprae(root, state);\n  const mo = new MutationObserver(mutations => {\n    for (const m of mutations) {\n      for (const el of m.addedNodes) {\n        if (el.nodeType === 1 && el[_state] === undefined) {\n          for (const attr of el.attributes) {\n            if (attr.name.startsWith(prefix)) {\n              root[_add](el); break;\n            }\n          }\n        }\n      }\n      // for (const el of m.removedNodes) el[Symbol.dispose]?.()\n    }\n  });\n  mo.observe(root, { childList: true, subtree: true });\n  return state\n}\n\n\n/**\n * Compiles an expression into an evaluator function.\n * @type {(dir:string, expr: string, clean?: string => string) => Function}\n */\nexport let compile\n\n/**\n * Parses an expression into an evaluator function, caching the result for reuse.\n *\n * @param {string} expr The expression to parse and compile into a function.\n * @returns {Function} The compiled evaluator function for the expression.\n */\nconst parse = (dir, expr, _clean = trim, _fn) => {\n  // expr.split(/\\bin\\b/)[1]\n  if (_fn = cache[expr = _clean(expr)]) return _fn\n\n  // static time errors\n  try { _fn = compile(expr) } catch (e) { console.error(`\u2234 ${e}\\n\\n${prefix + dir}=\"${expr}\"`) }\n\n  // run time errors\n  return cache[expr] = (s) => { try { return _fn?.(s) } catch (e) { console.error(`\u2234 ${e}\\n\\n${prefix + dir}=\"${expr}\"`) } }\n}\n\nexport const cache = {};\nexport const trim = e => e.trim()\n\n\n// apply modifiers to context (from the end due to nature of wrapping ctx.call)\nconst applyMods = (fn, mods) => {\n  while (mods.length) {\n    let [name, ...params] = mods.pop().split('-')\n    fn = sx(modifier[name]?.(fn, ...params) ?? fn, fn)\n  }\n  return fn\n}\n\n// soft-extend missing props and ignoring signals\nconst sx = (a, b) => { if (a != b) for (let k in b) (a[k] ??= b[k]); return a }\n\n// create expression setter, reflecting value back to state\nexport const setter = (dir, expr, _set = parse(dir, `${expr}=__`)) => (target, value) => {\n  // save value to stash\n  target.__ = value; _set(target), delete target.__\n}\n\n// instantiated <template> fragment holder, like persisting fragment but with minimal API surface\nexport const frag = (tpl) => {\n  if (!tpl.nodeType) return tpl // existing tpl\n\n  let content = tpl.content.cloneNode(true), // document fragment holder of content\n    attributes = [...tpl.attributes],\n    ref = document.createTextNode(''),\n    // ensure at least one node\n    childNodes = (content.append(ref), [...content.childNodes])\n\n  return {\n    // get parentNode() { return childNodes[0].parentNode },\n    childNodes,\n    content,\n    remove: () => content.append(...childNodes),\n    replaceWith(el) {\n      if (el === ref) return\n      ref.before(el)\n      content.append(...childNodes)\n    },\n    attributes,\n    removeAttribute(name) { attributes.splice(attributes.findIndex(a => a.name === name), 1) },\n    // setAttributeNode() { }\n  }\n}\n\n// if value is function - return result of its call\nexport const call = (v, arg) => typeof v === 'function' ? v(arg) : v\n\n// camel to kebab\nexport const dashcase = (str) => str.replace(/[A-Z\\u00C0-\\u00D6\\u00D8-\\u00DE]/g, (match, i) => (i ? '-' : '') + match.toLowerCase());\n\n// set attr\nexport const attr = (el, name, v) => (v == null || v === false) ? el.removeAttribute(name) : el.setAttribute(name, v === true ? \"\" : v);\n\n// convert any-arg to className string\nexport const clsx = (c, _out = []) => !c ? '' : typeof c === 'string' ? c : (\n  Array.isArray(c) ? c.map(clsx) :\n    Object.entries(c).reduce((s, [k, v]) => !v ? s : [...s, k], [])\n).join(' ')\n\n// throttle function to (once per tick or other custom scheduler)\nexport const throttle = (fn, schedule = queueMicrotask) => {\n  let _planned = 0;\n  const throttled = (e) => {\n    if (!_planned++) fn(e), schedule((_dirty = _planned > 1) => (\n      _planned = 0, _dirty && throttled(e)\n    ));\n  }\n  return throttled;\n}\n\n// find previous element matching the condition\nexport const prev = fn => {\n  let res = fn?.();\n  if (res) return res;\n  while (!res) el = el.previousSibling;\n\n  while (el && !el._holder) el = el.previousSibling || el.previousSibling?.previousSibling;\n  return el?._holder;\n}\n\nexport * from './store.js';\n\nexport default sprae\n", "// signals-based proxy\nimport { signal, computed, batch, untracked } from './core.js'\n\nconst mut = ['push', 'pop', 'shift', 'unshift', 'splice']\n\n// _signals allows both storing signals and checking instance, which would be difficult with WeakMap\nexport const _signals = Symbol('signals'),\n  _change = Symbol('change'),\n  _set = Symbol('set'),\n\n  // object store is not lazy\n  // parent defines parent scope or sandbox\n  store = (values, parent = globalThis) => {\n    if (!values) return values\n\n    // ignore existing state as argument or globals\n    // FIXME: toStringTag is not needed since we read global as parent\n    if (values[Symbol.toStringTag]) return values;\n\n    // bypass existing store\n    if (values[_signals]) return values\n\n    // non-objects: for array redirect to list\n    if (values.constructor !== Object) return Array.isArray(values) ? list(values) : values\n\n    // _change stores total number of keys to track new props\n    // NOTE: be careful\n    let len = Object.keys(values).length, signals = {}\n\n    // proxy conducts prop access to signals\n    let state = new Proxy(meta(signals, len), {\n      get: (_, k) => (k in signals ? (signals[k] ? signals[k].valueOf() : signals[k]) : parent[k]),\n      set: (_, k, v, _s) => (k in signals ? set(signals, k, v) : (create(signals, k, v), signals[_change].value = ++len), 1), // bump length for new signal\n      // FIXME: try to avild calling Symbol.dispose here\n      deleteProperty: (_, k) => (k in signals && (k[0] != '_' && signals[k]?.[Symbol.dispose]?.(), delete signals[k], signals[_change].value = --len), 1),\n      // subscribe to length when object is spread\n      ownKeys: () => (signals[_change].value, Reflect.ownKeys(signals)),\n      has: _ => 1 // sandbox prevents writing to global\n    }),\n\n      // init signals for values\n      descs = Object.getOwnPropertyDescriptors(values)\n\n    for (let k in values) {\n      // getter turns into computed\n      if (descs[k]?.get)\n        // stash setter\n        (signals[k] = computed(descs[k].get.bind(state)))[_set] = descs[k].set?.bind(state);\n\n      // init blank signal - make sure we don't take prototype one\n      else create(signals, k, values[k])\n    }\n\n    return state\n  },\n\n  // array store - signals are lazy since arrays can be very large & expensive\n  list = (values, parent = globalThis) => {\n\n    // track last accessed property to find out if .length was directly accessed from expression or via .push/etc method\n    let lastProp,\n\n      // gotta fill with null since proto methods like .reduce may fail\n      signals = Array(values.length).fill(null),\n\n      // proxy conducts prop access to signals\n      state = new Proxy(\n        meta(signals, signals.length),\n        {\n          get(_, k) {\n            // if .length is read within mutators - peek signal to avoid recursive subscription\n            if (k === 'length') return mut.includes(lastProp) ? signals.length : signals[_change].value;\n\n            lastProp = k;\n\n            // create signal (lazy)\n            // NOTE: if you decide to unlazy values, think about large arrays - init upfront can be costly\n            return signals[k] ? signals[k].valueOf() : k in signals ? (signals[k] = signal(store(values[k]))).valueOf() : parent[k]\n          },\n\n          set(_, k, v) {\n            // .length\n            if (k === 'length') {\n              // force cleaning up tail\n              for (let i = v; i < signals.length; i++) delete state[i]\n              // .length = N directly\n              signals[_change].value = signals.length = v;\n            }\n\n            // force changing length, if eg. a=[]; a[1]=1 - need to come after setting the item\n            else if (k >= signals.length) create(signals, k, v), state.length = +k + 1\n\n            // existing signal\n            else signals[k] ? set(signals, k, v) : create(signals, k, v)\n\n            return 1\n          },\n\n          // dispose notifies any signal deps, like :each\n          deleteProperty: (_, k) => (signals[k]?.[Symbol.dispose]?.(), delete signals[k], 1),\n        })\n\n    return state\n  },\n\n  // create signal value, skip untracked\n  create = (signals, k, v) => (signals[k] = k[0] == '_' || v?.peek ? v : signal(store(v))),\n\n  // set/update signal value\n  set = (signals, k, v, _s, _v) => {\n    // skip unchanged (although can be handled by last condition - we skip a few checks this way)\n    return k[0] === '_' ? (signals[k] = v) :\n      (v !== (_v = (_s = signals[k]).peek())) && (\n        // stashed _set for value with getter/setter\n        _s[_set] ? _s[_set](v) :\n          // patch array\n          Array.isArray(v) && Array.isArray(_v) ?\n            // if we update plain array (stored in signal) - take over value instead\n            // since input value can be store, we have to make sure we don't subscribe to its length or values\n            // FIXME: generalize to objects\n            _change in _v ? untracked(() => batch(() => {\n              for (let i = 0; i < v.length; i++) _v[i] = v[i]\n              _v.length = v.length // forces deleting tail signals\n            })) : _s.value = v :\n            // .x = y\n            (_s.value = store(v))\n      )\n  },\n\n  // create state meta props\n  meta = (signals, len) => (\n    Object.assign(signals, { [_change]: signal(len), [_signals]: signals })\n    // Object.defineProperties(signals, {\n    //   [_change]: { value: signal(len), enumerable: false },\n    //   [_signals]: { value: signals, enumerable: false }\n    // }),\n    // signals\n  )\n\n\n// make sure state contains first element of path, eg. `a` from `a.b[c]`\n// NOTE: we don't need since we force proxy sandbox\n// export const ensure = (state, expr, name = expr.match(/^\\w+(?=\\s*(?:\\.|\\[|$))/)) => name && (state[_signals][name[0]] ??= null)\n\nexport default store\n", "// preact-signals minimal implementation\nlet current, depth = 0, batched;\n\n// default signals impl\n\nexport const signal = (v, _s, _obs = new Set, _v = () => _s.value) => (\n  _s = {\n    get value() {\n      current?.deps.push(_obs.add(current));\n      return v\n    },\n    set value(val) {\n      if (val === v) return\n      v = val;\n      for (let sub of _obs) batched ? batched.add(sub) : sub(); // notify effects\n    },\n    peek() { return v },\n    toJSON: _v, then: _v, toString: _v, valueOf: _v\n  }\n)\n\nexport const effect = (fn, _teardown, _fx, _deps, __tmp) => (\n  _fx = (prev) => {\n    __tmp = _teardown;\n    _teardown = null; // we null _teardown to avoid repeated call in case of recursive update\n    __tmp?.call?.();\n    prev = current, current = _fx\n    if (depth++ > 10) throw 'Cycle detected';\n    try { _teardown = fn(); } finally { current = prev; depth-- }\n  },\n  _deps = _fx.deps = [],\n\n  _fx(),\n  (dep) => { _teardown?.call?.(); while (dep = _deps.pop()) dep.delete(_fx); }\n)\n\nexport const computed = (fn, _s = signal(), _c, _e, _v = () => _c.value) => (\n  _c = {\n    get value() {\n      _e ||= effect(() => _s.value = fn());\n      return _s.value\n    },\n    peek: _s.peek,\n    toJSON: _v, then: _v, toString: _v, valueOf: _v\n  }\n)\n\nexport const batch = (fn, _first = !batched) => {\n  batched ??= new Set;\n  try { fn(); }\n  finally { if (_first) { for (const fx of batched) fx(); batched = null } }\n}\n\nexport const untracked = (fn, _prev, _v) => (_prev = current, current = null, _v = fn(), current = _prev, _v)\n", "// \"centralized\" version of :if\nimport sprae, { throttle, _on, _off, _state, frag } from '../core.js';\n\n// :if=\"a\"\nexport default (el, state, _holder, _el, _match) => {\n  // new element :if\n  // console.log(':if init', el)\n  if (!el._holder) {\n    // mark el as fake-spraed to delay init, since we sprae rest when branch matches, both :if and :else :if\n    el[_state] ??= null\n\n    _el = el.content ? frag(el) : el\n\n    el.replaceWith(_holder = document.createTextNode(''))\n    _el._holder = _holder._holder = _holder\n\n\n    _holder._clauses = [_el._clause = [_el, false]]\n\n    _holder.update = throttle(() => {\n      let match = _holder._clauses.find(([, s]) => s)\n      // console.group(':if update clauses', ..._holder._clauses)\n\n      if (match != _match) {\n        // console.log(':if match', match)\n        _match?.[0].remove()\n        // FIXME: we don't turn off\n        _match?.[0][_off]?.()\n        if (_match = match) {\n          _holder.before(_match[0].content || _match[0])\n          // there's no :else after :if, so lazy-sprae here doesn't risk adding own destructor to own list of destructors\n          !_match[0][_state] ? (delete _match[0][_state], sprae(_match[0], state)) : _match[0][_on]?.()\n        }\n      }\n      // console.groupEnd()\n    })\n  }\n  // :else :if needs to be spraed all over to have clean list of offable effects\n  else sprae(_el = el, state)\n\n  // :else may have children to init which is called after :if\n  // or preact can schedule :else after :if, so we ensure order of call by next tick\n  return value => {\n    // console.log(':if update', _el, value)\n    _el._clause[1] = value\n    _el._holder.update()\n  }\n}\n", "import { _on, _off, _state, frag, prev } from '../core.js';\n\n\n// NOTE: we can reach :else counterpart whereas prev :else :if is on hold\nexport default (el, state, _el, _, _prev=el) => {\n\n  _el = el.content ? frag(el) : el\n\n  // find holder\n  while (_prev && !(_el._holder = _prev._holder)) _prev = _prev.previousSibling\n\n  el.remove()\n  el[_state] = null // mark as fake-spraed to stop further init, to lazy-sprae when branch matches\n\n  _el._holder._clauses.push(_el._clause = [_el, true])\n\n  return() => {\n    _el._holder.update()\n  }\n}\n", "import { frag, call } from \"../core.js\"\n\nexport default el => (\n  // <template :text=\"a\"/> or previously initialized template\n  // FIXME: replace with content maybe?\n  el.content && el.replaceWith(el = frag(el).childNodes[0]),\n  v => (v = call(v, el.textContent), el.textContent = v == null ? \"\" : v)\n)\n", "import { clsx, call } from \"../core.js\";\n\nexport default (el, _cur, _new) => (\n  _cur = new Set,\n  (v) => {\n    _new = new Set\n    if (v) clsx(call(v, el.className)).split(' ').map(c => c && _new.add(c))\n    for (let c of _cur) if (_new.has(c)) _new.delete(c); else el.classList.remove(c);\n    for (let c of _cur = _new) el.classList.add(c)\n  }\n)\n", "import { call, attr } from \"../core.js\";\n\nexport default (el, _static) => (\n  _static = el.getAttribute(\"style\"),\n  v => {\n    v = call(v, el.style)\n    if (typeof v === \"string\") attr(el, \"style\", _static + '; ' + v);\n    else {\n      if (_static) attr(el, \"style\", _static);\n      // NOTE: we skip names not starting with a letter - eg. el.style stores properties as { 0: --x } or JSDOM has _pfx\n      for (let k in v) k[0] == '-' ? el.style.setProperty(k, v[k]) : k[0] > 'A' && (el.style[k] = v[k])\n    }\n  }\n)\n", "import { call } from \"../core.js\"\n\nexport default () => v => (call(v))\n", "import sprae,{ setter, attr, cache, trim, _state } from \"../core.js\";\n\nexport default (el, state, expr, name) => {\n  // bind back to value, but some values can be not bindable, eg. `:value=\"7\"`\n  try {\n    const set = setter(name, expr)\n    const handleChange = el.type === 'checkbox' ? () => set(state, el.checked) :\n      el.type === 'select-multiple' ? () => set(state, [...el.selectedOptions].map(o => o.value)) :\n        () => set(state, el.selectedIndex < 0 ? null : el.value)\n\n    el.oninput = el.onchange = handleChange; // hope user doesn't redefine these manually via `.oninput = somethingElse` - it saves 5 loc vs addEventListener\n\n    if (el.type?.startsWith('select')) {\n      // select element also must observe any added/removed options or changed values (outside of sprae)\n      new MutationObserver(handleChange).observe(el, { childList: true, subtree: true, attributes: true });\n\n      // select options must be initialized before calling an update\n      sprae(el, state)\n    }\n\n    // initial state value - setter has already cached it, no need to parse again\n    cache[trim(expr)](state) ?? handleChange()\n  } catch { }\n\n  return (el.type === \"text\" || el.type === \"\") ?\n    (value) => el.setAttribute(\"value\", (el.value = value == null ? \"\" : value)) :\n    (el.tagName === \"TEXTAREA\" || el.type === \"text\" || el.type === \"\") ?\n      (value, from, to) => (\n        // we retain selection in input\n        (from = el.selectionStart),\n        (to = el.selectionEnd),\n        el.setAttribute(\"value\", (el.value = value == null ? \"\" : value)),\n        from && el.setSelectionRange(from, to)\n      ) :\n      (el.type === \"checkbox\") ?\n        (value) => (el.checked = value, attr(el, \"checked\", value)) :\n        (el.type === 'radio') ? (value) => (\n          el.value === value && ((el.checked = value), attr(el, 'checked', value))\n        ) :\n          (el.type === \"select-one\") ?\n            (value) => {\n              for (let o of el.options)\n                o.value == value ? o.setAttribute(\"selected\", '') : o.removeAttribute(\"selected\");\n              el.value = value;\n            } :\n            (el.type === 'select-multiple') ? (value) => {\n              for (let o of el.options) o.removeAttribute('selected')\n              for (let v of value) el.querySelector(`[value=\"${v}\"]`).setAttribute('selected', '')\n            } :\n              (value) => (el.value = value);\n}\n", "import { setter, cache, trim } from \"../core.js\"\n\nexport default (el, state, expr, name, _prev, _set) => (\n  typeof cache[trim(expr)](state) == 'function' ?\n    v => (v(el)) :\n    // NOTE: we have to set element statically (outside of effect) to avoid parasitic sub - multiple els with same :ref can cause recursion (eg. :each :ref=\"x\")\n    (setter(name, expr)(state, el))\n)\n", "import sprae, { store, call, untracked, _state } from '../core.js'\n\nexport default (el, rootState, _scope) => (\n  // prevent subsequent effects\n  el[_state] = null,\n  // 0 run pre-creates state to provide scope for the first effect - it can write vars in it, so we should already have it\n  _scope = store({}, rootState),\n  // 1st run spraes subtree with values from scope - it can be postponed by modifiers (we isolate reads from parent effect)\n  // 2nd+ runs update _scope\n  values => (Object.assign(_scope, call(values, _scope)), el[_state] ?? (delete el[_state], untracked(() => sprae(el, _scope))))\n)\n", "import sprae, { store, _state, effect, _change, _signals, frag, throttle } from \"../core.js\";\n\nconst each = (tpl, state, expr) => {\n  let [itemVar, idxVar = \"$\"] = expr.split(/\\bin\\b/)[0].trim().replace(/\\(|\\)/g, '').split(/\\s*,\\s*/);\n\n  // we need :if to be able to replace holder instead of tpl for :if :each case\n  let holder = document.createTextNode(\"\");\n\n  // we re-create items any time new items are produced\n  let cur, keys, items, prevl = 0\n\n  // FIXME: pass items to update instead of global\n  let update = throttle(() => {\n    let i = 0, newItems = items, newl = newItems.length\n\n    // plain array update, not store (signal with array) - updates full list\n    if (cur && !cur[_change]) {\n      for (let s of cur[_signals] || []) s[Symbol.dispose]()\n      cur = null, prevl = 0\n    }\n\n    // delete\n    if (newl < prevl) cur.length = newl\n\n    // update, append, init\n    else {\n      // init\n      if (!cur) cur = newItems\n      // update\n      else while (i < prevl) cur[i] = newItems[i++]\n\n      // append\n      for (; i < newl; i++) {\n        cur[i] = newItems[i]\n\n        let idx = i,\n          // FIXME: inherited state is cheaper in terms of memory and faster in terms of performance, compared to creating a proxy\n          subscope = store({\n            // NOTE: since we simulate signal, we have to make sure it's actual signal, not fake one\n            // FIXME: try to avoid this, we also have issue with wrongly calling dispose in store on delete\n            [itemVar]: cur[_signals]?.[idx]?.peek ? cur[_signals]?.[idx] : cur[idx],\n            [idxVar]: keys ? keys[idx] : idx\n          }, state)\n        // subscope = Object.create(state, {\n        //   [itemVar]: { get: () => cur[idx] },\n        //   [idxVar]: { value: keys ? keys[idx] : idx }\n        // })\n\n        let el = tpl.content ? frag(tpl) : tpl.cloneNode(true);\n\n        holder.before(el.content || el);\n\n        sprae(el, subscope);\n\n        // signal/holder disposal removes element\n        let _prev = ((cur[_signals] ||= [])[i] ||= {})[Symbol.dispose]\n        cur[_signals][i][Symbol.dispose] = () => {\n          _prev?.(), el[Symbol.dispose]?.(), el.remove()\n        };\n      }\n    }\n\n    prevl = newl\n  })\n\n  tpl.replaceWith(holder);\n  tpl[_state] = null // mark as fake-spraed, to preserve :-attribs for template\n\n  return value => {\n    // resolve new items\n    keys = null\n    if (typeof value === \"number\") items = Array.from({ length: value }, (_, i) => i + 1)\n    else if (value?.constructor === Object) keys = Object.keys(value), items = Object.values(value)\n    else items = value || []\n\n    // whenever list changes, we rebind internal change effect\n    return effect(() => {\n      // subscribe to items change (.length) - we do it every time (not just in update) since preact unsubscribes unused signals\n      items[_change]?.value\n\n      // make first render immediately, debounce subsequent renders\n      update()\n    })\n  }\n}\n\n// :each directive skips v, k\neach.clean = (str) => str.split(/\\bin\\b/)[1].trim()\n\nexport default each\n", "import { attr, call } from \"../core.js\";\n\nexport default (el, st, ex, name) => v => attr(el, name, call(v, el.getAttribute(name)))\n", "import { attr, dashcase } from \"../core.js\";\n\nexport default (target) => value => { for (let key in value) attr(target, dashcase(key), value[key]) }\n", "import store, { _change, _signals } from \"./store.js\";\nimport { batch, computed, effect, signal, untracked } from './signal.js';\nimport sprae, { use, start, _off, _state, _on, _dispose, throttle, _add } from './core.js';\n\nimport _if from \"./directive/if.js\";\nimport _else from \"./directive/else.js\";\nimport _text from \"./directive/text.js\";\nimport _class from \"./directive/class.js\";\nimport _style from \"./directive/style.js\";\nimport _fx from \"./directive/fx.js\";\nimport _value from \"./directive/value.js\";\nimport _ref from \"./directive/ref.js\";\nimport _scope from \"./directive/scope.js\";\nimport _each from \"./directive/each.js\";\nimport _default from \"./directive/default.js\";\nimport _spread from \"./directive/spread.js\";\n\n\nconst directive =  {\n  // :x=\"x\"\n  '*': _default,\n\n  // :=\"{a,b,c}\"\n  '': _spread,\n\n  // :class=\"[a, b, c]\"\n  class: _class,\n\n  // :text=\"...\"\n  text: _text,\n\n  // :style=\"...\"\n  style: _style,\n\n  // :fx=\"...\"\n  fx: _fx,\n\n  // :value - 2 way binding like x-model\n  value: _value,\n\n  // :ref=\"...\"\n  ref: _ref,\n\n  // :scope creates variables scope for a subtree\n  scope: _scope,\n\n  if: _if,\n  else: _else,\n\n  // :each=\"v,k in src\"\n  each: _each\n}\n\nconst modifier = {\n  // FIXME: add -s, -m, -l classes with values\n  debounce: (fn,\n    _how = 250,\n    _schedule = _how === \"tick\" ? queueMicrotask : _how === \"raf\" ? requestAnimationFrame : _how === \"idle\" ? requestIdleCallback : ((fn) => setTimeout(fn, _how)),\n    _count = 0\n  ) =>\n    (e, _planned=++_count) => (_schedule(() => (_planned == _count && fn(e)))),\n\n  throttle: (fn, _how = 250, _schedule = _how === \"tick\" ? queueMicrotask : _how === \"raf\" ? requestAnimationFrame : ((fn) => setTimeout(fn, _how))) => (\n    throttle(fn, _schedule)\n  ),\n\n  once: (fn, _done, _fn) => Object.assign((e) => !_done && (_done = 1, fn(e)), { once: true }),\n\n  // event modifiers\n  // actions\n  prevent: (fn) => (e) => (e?.preventDefault(), fn(e)),\n  stop: (fn) => (e) => (e?.stopPropagation(), fn(e)),\n  immediate: (fn) => (e) => (e?.stopImmediatePropagation(), fn(e)),\n\n  // options\n  passive: fn => (fn.passive = true, fn),\n  capture: fn => (fn.capture = true, fn),\n\n  // target\n  window: fn => (fn.target = window, fn),\n  document: fn => (fn.target = document, fn),\n  parent: fn => (fn.target = fn.target.parentNode, fn),\n\n  // test\n  self: (fn) => (e) => (e.target === fn.target && fn(e)),\n  // FIXME\n  outside: (fn) => (e, _target) => (\n    _target = fn.target,\n    !_target.contains(e.target) && e.target.isConnected && (_target.offsetWidth || _target.offsetHeight)\n  ),\n\n  // FIXME:\n  //screen: fn => ()\n}\n\n// key testers\nconst keys = {\n  ctrl: e => e.ctrlKey || e.key === \"Control\" || e.key === \"Ctrl\",\n  shift: e => e.shiftKey || e.key === \"Shift\",\n  alt: e => e.altKey || e.key === \"Alt\",\n  meta: e => e.metaKey || e.key === \"Meta\" || e.key === \"Command\",\n  arrow: e => e.key.startsWith(\"Arrow\"),\n  enter: e => e.key === \"Enter\",\n  esc: e => e.key.startsWith(\"Esc\"),\n  tab: e => e.key === \"Tab\",\n  space: e => e.key === \"\u00A0\" || e.key === \"Space\" || e.key === \" \",\n  delete: e => e.key === \"Delete\" || e.key === \"Backspace\",\n  digit: e => /^\\d$/.test(e.key),\n  letter: e => /^\\p{L}$/gu.test(e.key),\n  char: e => /^\\S$/.test(e.key),\n};\n\n// augment modifiers with key testers\nfor (let k in keys) modifier[k] = (fn, ...params) => (e) => keys[k](e) && params.every(k => keys[k]?.(e) ?? e.key === k) && fn(e)\n\n\nuse({\n  directive,\n  modifier,\n\n  // indirect new Function to avoid detector\n  compile: expr => sprae.constructor(`with (arguments[0]) { return ${expr} };`),\n\n  // signals\n  signal, effect, computed, batch, untracked\n})\n\nexport default sprae\nexport { sprae, store, signal, effect, computed, batch, untracked, use, start }\n", "\nvar {default:sprae, use, start} = require(\"./sprae.js\");\nmodule.exports = sprae;\nuse({ prefix: document.currentScript.getAttribute(\"prefix\") || document.currentScript.dataset.spraePrefix || ':' })\nstart();"],
  "mappings": "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",
  "names": ["el", "fn", "off", "prev", "attr", "_set", "signal", "effect", "computed", "batch", "untracked", "prev", "el", "el", "el", "el", "el", "el", "set", "el", "_set", "el", "keys", "el", "el", "batch", "computed", "effect", "signal", "untracked", "directive", "modifier", "fn", "k", "sprae", "use", "start"]
}
